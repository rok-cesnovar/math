<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: Type Traits</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/de1/group__type__trait.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Type Traits</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The type traits in Stan math are a mix of custom traits for detecting value and container types of <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrices, standard vectors, standard complex numbers, and backports of C++17 traits. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dbb/structstan_1_1math_1_1ad__promotable.html">stan::math::ad_promotable&lt; From, To, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type From can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true.  <a href="../../da/dbb/structstan_1_1math_1_1ad__promotable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d76/structstan_1_1math_1_1append__return__type.html">stan::math::append_return_type&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d4/d76/structstan_1_1math_1_1append__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html">stan::math::append_return_type&lt; int, int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="../../d4/dff/structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/daa/structstan_1_1base__type.html">stan::base_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base base type of a template argument.  <a href="../../d1/daa/structstan_1_1base__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d7a/structstan_1_1math_1_1child__type.html">stan::math::child_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute child type of T.  <a href="../../d6/d7a/structstan_1_1math_1_1child__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html">stan::math::child_type&lt; T_struct&lt; T_child &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for template classes / structs.  <a href="../../de/dc1/structstan_1_1math_1_1child__type_3_01_t__struct_3_01_t__child_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">stan::math::conjunction&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with zero or more template parameters, all of which extend the std::true_type.  <a href="../../da/d56/structstan_1_1math_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">stan::math::disjunction&lt; Conds &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::false_type when instantiated with zero or more template parameters, all of which extend the std::false_type.  <a href="../../d8/d3d/structstan_1_1math_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dda/structstan_1_1math_1_1include__summand.html">stan::math::include_summand&lt; propto, T, T_pack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate whether a summand needs to be included in a proportional (log) probability calculation.  <a href="../../d1/dda/structstan_1_1math_1_1include__summand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dc3/structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">stan::math::include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if a term with the specified propto value and subterm types should be included in a proportionality calculation.  <a href="../../da/dc3/structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d9a/structstan_1_1math_1_1index__type.html">stan::math::index_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="../../de/d9a/structstan_1_1math_1_1index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">stan::math::index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="../../d7/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::math::index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, vector, or row vector.  <a href="../../de/d10/structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dff/structstan_1_1is__autodiff.html">stan::is_autodiff&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var or fvar.  <a href="../../d1/dff/structstan_1_1is__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html">stan::internal::is_complex_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member constant <code>value</code> which is equal to <code>true</code> if <code>T</code> is an instance of <code>std::complex</code> and <code>false</code> otherwise.  <a href="../../d5/de1/structstan_1_1internal_1_1is__complex__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d57/structstan_1_1is__complex.html">stan::is_complex&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>T</code> is an arithmetic type (that is, an instance of <code>std::complex</code>) or a cv-qualified version thereof, provides the member constant <code>value</code> equal <code>true</code>; for any other type the value is <code>false</code>.  <a href="../../d0/d57/structstan_1_1is__complex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d70/structstan_1_1is__constant.html">stan::is_constant&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogramming struct to detect whether a given type is constant in the mathematical sense (not the C++ <code>const</code> sense).  <a href="../../d5/d70/structstan_1_1is__constant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d0f/structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value and sets it to true if the type of the elements in the provided std::vector is constant, false otherwise.  <a href="../../da/d0f/structstan_1_1is__constant_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d39/structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">stan::is_constant&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a public enum named value and sets it to true if the type of the elements in the provided <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is constant, false otherwise.  <a href="../../d6/d39/structstan_1_1is__constant_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d41/structstan_1_1is__double__or__int.html">stan::is_double_or_int&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a double or integer.  <a href="../../dd/d41/structstan_1_1is__double__or__int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7d/structstan_1_1is__eigen.html">stan::is_eigen&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation to check whether a type is derived from EigenBase.  <a href="../../dc/d7d/structstan_1_1is__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d54/structstan_1_1is__eigen__matrix.html">stan::is_eigen_matrix&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Matrix</code> or <code>Eigen::SparseMatrix</code>  <a href="../../d8/d54/structstan_1_1is__eigen__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">stan::is_eigen_array&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Array</code>  <a href="../../dc/d22/structstan_1_1is__eigen__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html">stan::is_eigen_contiguous_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Map</code> with contiguous stride.  <a href="../../d7/d7c/structstan_1_1is__eigen__contiguous__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">stan::is_fvar&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member function type which is defined to be false as the primitive scalar types cannot be a <a class="el" href="../../d0/dfb/structstan_1_1math_1_1fvar.html" title="This template class represents scalars used in forward-mode automatic differentiation, which consist of values and directional derivatives of the specified template type. ">stan::math::fvar</a> type.  <a href="../../d4/df3/structstan_1_1is__fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d8f/structstan_1_1is__stan__scalar.html">stan::is_stan_scalar&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if decayed type is a var, fvar, or arithmetic.  <a href="../../da/d8f/structstan_1_1is__stan__scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d9d/structstan_1_1is__var.html">stan::is_var&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member named value which is defined to be false as the primitive scalar types cannot be a <a class="el" href="../../d1/d39/classstan_1_1math_1_1var.html" title="Independent (input) and dependent (output) variables for gradients. ">stan::math::var</a> type.  <a href="../../df/d9d/structstan_1_1is__var.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">stan::is_var_or_arithmetic_type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a static member value which is defined to be true (1) if the unqualified cv of type T or its underlying type (if a container) is either var or an arithmetic type, and false (0) otherwise.  <a href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">stan::is_std_vector&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for checking if type is std vector.  <a href="../../d0/db6/structstan_1_1is__std__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d1b/structstan_1_1internal_1_1is__eigen__col__vector__impl.html">stan::internal::is_eigen_col_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is a column vector.  <a href="../../d0/d1b/structstan_1_1internal_1_1is__eigen__col__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d04/structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_col_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="../../d3/d04/structstan_1_1internal_1_1is__eigen__col__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dbc/structstan_1_1internal_1_1is__eigen__row__vector__impl.html">stan::internal::is_eigen_row_vector_impl&lt; T, bool &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Underlying implementation for detecting if an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Matrix is a row vector.  <a href="../../d1/dbc/structstan_1_1internal_1_1is__eigen__row__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd7/structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html">stan::internal::is_eigen_row_vector_impl&lt; T, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for when type is not an eigen vector.  <a href="../../d3/dd7/structstan_1_1internal_1_1is__eigen__row__vector__impl_3_01_t_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d37/structstan_1_1is__eigen__col__vector.html">stan::is_eigen_col_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 row at compile time this has a static member with a value of true.  <a href="../../d6/d37/structstan_1_1is__eigen__col__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc1/structstan_1_1is__eigen__row__vector.html">stan::is_eigen_row_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column at compile time this has a static member with a value of true.  <a href="../../dd/dc1/structstan_1_1is__eigen__row__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d3b/structstan_1_1is__eigen__vector.html">stan::is_eigen_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is an eigen matrix with 1 column or 1 row at compile time this has a static member with a value of true.  <a href="../../d7/d3b/structstan_1_1is__eigen__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d82/structstan_1_1is__vector.html">stan::is_vector&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the input type T is either an eigen matrix with 1 column or 1 row at compile time or a standard vector, this has a static member with a value of true.  <a href="../../d4/d82/structstan_1_1is__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d0c/structstan_1_1internal_1_1is__std__vector__impl.html">stan::internal::is_std_vector_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This underlying implementation is used when the type is not an std vector.  <a href="../../d4/d0c/structstan_1_1internal_1_1is__std__vector__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d45/structstan_1_1is__vector__like.html">stan::is_vector_like&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram indicates whether a type is vector_like.  <a href="../../d3/d45/structstan_1_1is__vector__like.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/dd1/classstan_1_1math_1_1internal_1_1ops__partials__edge.html">stan::math::internal::ops_partials_edge&lt; ViewElt, Op, Enable &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge holds both the operands and its associated partial derivatives.  <a href="../../d5/dd1/classstan_1_1math_1_1internal_1_1ops__partials__edge.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template builds partial derivatives with respect to a set of operands.  <a href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d04/structstan_1_1partials__return__type.html">stan::partials_return_type&lt; T, T_pack &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the partial derivative type resulting from promoting all the scalar types of the template parameters.  <a href="../../d3/d04/structstan_1_1partials__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/db7/structstan_1_1partials__type.html">stan::partials_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This base implementation will contain a static member function named type equal to the type passed into it.  <a href="../../d0/db7/structstan_1_1partials__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc1/structstan_1_1real__return.html">stan::real_return&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a member type alias named <code>type</code>, the value of which is the least type under Stan's assignability relation that can be assigned a <code>double</code> and all of the base types of the specified arguments after removing qualifiers (<code>const</code> and <code>volatile</code>) and decaying (lvalue to rvalue by removing references) and array to pointer).  <a href="../../d0/dc1/structstan_1_1real__return.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d1d/structstan_1_1scalar__lub.html">stan::scalar_lub&lt; T1, T2 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a member type named <code>type</code> that is the least scalar type to which both template parameter scalar types are assignable in Stan.  <a href="../../d5/d1d/structstan_1_1scalar__lub.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d68/structstan_1_1return__type.html">stan::return_type&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar types of the template parameters to the least type to which all the base types of the arguments are assignable.  <a href="../../d8/d68/structstan_1_1return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d32/classstan_1_1scalar__seq__view.html">stan::scalar_seq_view&lt; C, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d32/classstan_1_1scalar__seq__view.html" title="scalar_seq_view provides a uniform sequence-like wrapper around either a scalar or a sequence of scal...">scalar_seq_view</a> provides a uniform sequence-like wrapper around either a scalar or a sequence of scalars.  <a href="../../d0/d32/classstan_1_1scalar__seq__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dd9/structstan_1_1scalar__type.html">stan::scalar_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the base scalar type of a template argument.  <a href="../../d6/dd9/structstan_1_1scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d53/structstan_1_1scalar__type__pre.html">stan::scalar_type_pre&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram structure to determine the type of first container of the base scalar type of a template argument.  <a href="../../d5/d53/structstan_1_1scalar__type__pre.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/db9/classstan_1_1_std_vector_builder.html">stan::StdVectorBuilder&lt; used, T1, T2, T3, T4, T5, T6, T7 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../df/db9/classstan_1_1_std_vector_builder.html" title="StdVectorBuilder allocates type T1 values to be used as intermediate values. ">StdVectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../df/db9/classstan_1_1_std_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d27/structstan_1_1value__type.html">stan::value_type&lt; T, typename &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for metaprogram to compute the type of values stored in a container.  <a href="../../dd/d27/structstan_1_1value__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d03/classstan_1_1vector__seq__view.html">stan::vector_seq_view&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides a low-cost wrapper for situations where you either need an <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Vector or RowVector or a std::vector of them and you want to be agnostic between those two options.  <a href="../../db/d03/classstan_1_1vector__seq__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html">stan::VectorBuilder&lt; used, T1, Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values. ">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../da/d7e/classstan_1_1_vector_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d66/classstan_1_1_vector_builder_helper.html">stan::VectorBuilderHelper&lt; T1, used, is_vec &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d7e/classstan_1_1_vector_builder.html" title="VectorBuilder allocates type T1 values to be used as intermediate values. ">VectorBuilder</a> allocates type T1 values to be used as intermediate values.  <a href="../../d6/d66/classstan_1_1_vector_builder_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dfa/classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html">stan::VectorBuilderHelper&lt; T1, true, true &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for using a vector.  <a href="../../d2/dfa/classstan_1_1_vector_builder_helper_3_01_t1_00_01true_00_01true_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/d25/classstan_1_1math_1_1internal_1_1ops__partials__edge_3_01double_00_01var_01_4.html">stan::math::internal::ops_partials_edge&lt; double, var &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/de8/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01var_01_4.html">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="../../d2/de8/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01var_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html">stan::partials_type&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of partials type returns double if input type is a double.  <a href="../../d4/da0/structstan_1_1partials__type_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplParams" colspan="2">template&lt;bool B&gt; </td></tr>
<tr class="memitem:gad1046e42476333dc3c08c35bfe420302"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = std::integral_constant&lt; bool, B &gt;</td></tr>
<tr class="memdesc:gad1046e42476333dc3c08c35bfe420302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for structs used for wraps a static constant of bool.  <a href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">More...</a><br /></td></tr>
<tr class="separator:gad1046e42476333dc3c08c35bfe420302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76542442910faefbee636785a9f34091"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga76542442910faefbee636785a9f34091"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">stan::contains_fvar</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;&gt;... &gt;</td></tr>
<tr class="memdesc:ga76542442910faefbee636785a9f34091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with at least 1 template parameter that is a fvar.  <a href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">More...</a><br /></td></tr>
<tr class="separator:ga76542442910faefbee636785a9f34091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">is_std_vector</a>&lt; Ts &gt;... &gt;</td></tr>
<tr class="memdesc:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any types are std vectors.  <a href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">More...</a><br /></td></tr>
<tr class="separator:gaaa1b1eb615a4b1b30b46ef33ace88cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4285e1bff93354519204a845b6c5348b"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga4285e1bff93354519204a845b6c5348b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga4285e1bff93354519204a845b6c5348b">stan::contains_vector</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d4/d82/structstan_1_1is__vector.html">is_vector</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga4285e1bff93354519204a845b6c5348b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram to determine if any of the provided types is a std or eigen vector.  <a href="../../d8/de1/group__type__trait.html#ga4285e1bff93354519204a845b6c5348b">More...</a><br /></td></tr>
<tr class="separator:ga4285e1bff93354519204a845b6c5348b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="../../d5/d70/structstan_1_1is__constant.html">is_constant</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise.  <a href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">More...</a><br /></td></tr>
<tr class="separator:ga880b82cbb2b83ccaba2426e73996b8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87910dd57a921a668530336311ab4382"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga87910dd57a921a668530336311ab4382"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga87910dd57a921a668530336311ab4382">stan::is_eigen_matrix_or_array</a> = <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt; <a class="el" href="../../d8/d54/structstan_1_1is__eigen__matrix.html">is_eigen_matrix</a>&lt; T &gt;, <a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:ga87910dd57a921a668530336311ab4382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a type is an <code>Eigen::Matrix</code> or <code>Eigen::SparseMatrix</code> or <code>Eigen::Array</code>  <a href="../../d8/de1/group__type__trait.html#ga87910dd57a921a668530336311ab4382">More...</a><br /></td></tr>
<tr class="separator:ga87910dd57a921a668530336311ab4382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0f2252ae22390725feb09d9ea11b7896"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = std::is_convertible&lt; T, std::string &gt;</td></tr>
<tr class="memdesc:ga0f2252ae22390725feb09d9ea11b7896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces whether type is convertible to string.  <a href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">More...</a><br /></td></tr>
<tr class="separator:ga0f2252ae22390725feb09d9ea11b7896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplParams" colspan="2">template&lt;typename... T&gt; </td></tr>
<tr class="memitem:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt; T &gt;... &gt;</td></tr>
<tr class="memdesc:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise.  <a href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">More...</a><br /></td></tr>
<tr class="separator:ga9d36a4d6158f96c2321b4fbf55243ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typename <a class="el" href="../../d0/db7/structstan_1_1partials__type.html">partials_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga1310fb459dbad72fa5594b6d1eaad959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper alias for accessing the partial type.  <a href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">More...</a><br /></td></tr>
<tr class="separator:ga1310fb459dbad72fa5594b6d1eaad959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ga546483131616701876a9f1307f5a413d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typename boost::math::tools::promote_args&lt; Args... &gt;::type</td></tr>
<tr class="memdesc:ga546483131616701876a9f1307f5a413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience alias for boost tools promote_args.  <a href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">More...</a><br /></td></tr>
<tr class="separator:ga546483131616701876a9f1307f5a413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typename <a class="el" href="../../d0/dc1/structstan_1_1real__return.html">real_return</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gac9d3fe14d5102916bf0b5b05712c833e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the real return type.  <a href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">More...</a><br /></td></tr>
<tr class="separator:gac9d3fe14d5102916bf0b5b05712c833e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">stan::complex_return_t</a> = std::complex&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;&gt;</td></tr>
<tr class="memdesc:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">More...</a><br /></td></tr>
<tr class="separator:ga6c52a0fffdfffc70123211cead9c7dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad4ed0103c48143e708de631fbb83a7f"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gaad4ed0103c48143e708de631fbb83a7f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">stan::std_vector_return_t</a> = std::vector&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;&gt;</td></tr>
<tr class="memdesc:gaad4ed0103c48143e708de631fbb83a7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">More...</a><br /></td></tr>
<tr class="separator:gaad4ed0103c48143e708de631fbb83a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, -1 &gt;</td></tr>
<tr class="memdesc:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">More...</a><br /></td></tr>
<tr class="separator:gab3412a1caaad7f8eef55a9ee2a0d3921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga1b070b6ae219eccccf07b44243307b8b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, -1, 1 &gt;</td></tr>
<tr class="memdesc:ga1b070b6ae219eccccf07b44243307b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">More...</a><br /></td></tr>
<tr class="separator:ga1b070b6ae219eccccf07b44243307b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = Eigen::Matrix&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; Ts... &gt;, 1, -1 &gt;</td></tr>
<tr class="memdesc:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">More...</a><br /></td></tr>
<tr class="separator:ga2fa4e21b37c08e6abce2919ac4c2cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typename <a class="el" href="../../d5/d1d/structstan_1_1scalar__lub.html">scalar_lub</a>&lt; T1, T2 &gt;::type</td></tr>
<tr class="memdesc:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering.  <a href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">More...</a><br /></td></tr>
<tr class="separator:gace9d2d5da99a3e14fcadd7bf0f6cffee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typename <a class="el" href="../../d8/d68/structstan_1_1return__type.html">return_type</a>&lt; Ts... &gt;::type</td></tr>
<tr class="memdesc:gacbaff683cd2683209e6855e2c7aaeffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience type for the return type of the specified template parameters.  <a href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">More...</a><br /></td></tr>
<tr class="separator:gacbaff683cd2683209e6855e2c7aaeffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57121ded0440567e8dfb0d80b1290922"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typename <a class="el" href="../../dd/d27/structstan_1_1value__type.html">value_type</a>&lt; T &gt;::type</td></tr>
<tr class="memdesc:ga57121ded0440567e8dfb0d80b1290922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for accessing underlying type.  <a href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">More...</a><br /></td></tr>
<tr class="separator:ga57121ded0440567e8dfb0d80b1290922"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae29786dab3b9274d3f1d08f6904854eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#afce03dc72ef9b35eb9045d3c7b060fd5">T_return_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gae29786dab3b9274d3f1d08f6904854eb">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, fvar&lt; Dx &gt; &gt;::build</a> (Dx value)</td></tr>
<tr class="memdesc:gae29786dab3b9274d3f1d08f6904854eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#gae29786dab3b9274d3f1d08f6904854eb">More...</a><br /></td></tr>
<tr class="separator:gae29786dab3b9274d3f1d08f6904854eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad2a93cdd718b76d4994d0f7c6c05fbba">stan::get</a> (const T &amp;x, size_t n)</td></tr>
<tr class="memdesc:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the provided element.  <a href="../../d8/de1/group__type__trait.html#gad2a93cdd718b76d4994d0f7c6c05fbba">More...</a><br /></td></tr>
<tr class="separator:gad2a93cdd718b76d4994d0f7c6c05fbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga431bd201f09a215cccb16cda10a1e840"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga431bd201f09a215cccb16cda10a1e840">stan::get</a> (const std::vector&lt; T &gt; &amp;x, size_t n)</td></tr>
<tr class="memdesc:ga431bd201f09a215cccb16cda10a1e840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the n-th element of the provided std::vector.  <a href="../../d8/de1/group__type__trait.html#ga431bd201f09a215cccb16cda10a1e840">More...</a><br /></td></tr>
<tr class="separator:ga431bd201f09a215cccb16cda10a1e840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafadbbba7194b85b76f6045dcb605351f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafadbbba7194b85b76f6045dcb605351f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gafadbbba7194b85b76f6045dcb605351f">stan::math::size</a> (const T &amp;)</td></tr>
<tr class="memdesc:gafadbbba7194b85b76f6045dcb605351f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of primitive scalar types that are always of length 1.  <a href="../../d8/de1/group__type__trait.html#gafadbbba7194b85b76f6045dcb605351f">More...</a><br /></td></tr>
<tr class="separator:gafadbbba7194b85b76f6045dcb605351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0cca2c6f7e5fd2ba86713a4057e74d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_not_stan_scalar_t&lt;T&gt;, typename  = void&gt; </td></tr>
<tr class="memitem:gaa0cca2c6f7e5fd2ba86713a4057e74d3"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaa0cca2c6f7e5fd2ba86713a4057e74d3">stan::math::size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:gaa0cca2c6f7e5fd2ba86713a4057e74d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the provided <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, expression or std::vector.  <a href="../../d8/de1/group__type__trait.html#gaa0cca2c6f7e5fd2ba86713a4057e74d3">More...</a><br /></td></tr>
<tr class="separator:gaa0cca2c6f7e5fd2ba86713a4057e74d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b84d1b1408266cd9f8a37cbec2766d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0b84d1b1408266cd9f8a37cbec2766d6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0b84d1b1408266cd9f8a37cbec2766d6">stan::math::size_mvt</a> (const T &amp;)</td></tr>
<tr class="memdesc:ga0b84d1b1408266cd9f8a37cbec2766d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the size of a multivariate argument.  <a href="../../d8/de1/group__type__trait.html#ga0b84d1b1408266cd9f8a37cbec2766d6">More...</a><br /></td></tr>
<tr class="separator:ga0b84d1b1408266cd9f8a37cbec2766d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbc8947aae651b674f5935b7531d7939"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafbc8947aae651b674f5935b7531d7939"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gafbc8947aae651b674f5935b7531d7939">stan::math::as_array_or_scalar</a> (const T &amp;v)</td></tr>
<tr class="memdesc:gafbc8947aae651b674f5935b7531d7939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specified input value.  <a href="../../d8/de1/group__type__trait.html#gafbc8947aae651b674f5935b7531d7939">More...</a><br /></td></tr>
<tr class="separator:gafbc8947aae651b674f5935b7531d7939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8bd3e9a682f845429678cd1a04986f1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad8bd3e9a682f845429678cd1a04986f1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gad8bd3e9a682f845429678cd1a04986f1">stan::math::as_array_or_scalar</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:gad8bd3e9a682f845429678cd1a04986f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a std::vector type to an array.  <a href="../../d8/de1/group__type__trait.html#gad8bd3e9a682f845429678cd1a04986f1">More...</a><br /></td></tr>
<tr class="separator:gad8bd3e9a682f845429678cd1a04986f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga172517131afb410729d2c7000006b494"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga172517131afb410729d2c7000006b494"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga172517131afb410729d2c7000006b494">stan::math::as_column_vector_or_scalar</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ga172517131afb410729d2c7000006b494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts input argument to a column vector or a scalar.  <a href="../../d8/de1/group__type__trait.html#ga172517131afb410729d2c7000006b494">More...</a><br /></td></tr>
<tr class="separator:ga172517131afb410729d2c7000006b494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57cfb81065d428e618af45cdba5f1f99"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga57cfb81065d428e618af45cdba5f1f99"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga57cfb81065d428e618af45cdba5f1f99">stan::math::as_column_vector_or_scalar</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga57cfb81065d428e618af45cdba5f1f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts input argument to a column vector or a scalar.  <a href="../../d8/de1/group__type__trait.html#ga57cfb81065d428e618af45cdba5f1f99">More...</a><br /></td></tr>
<tr class="separator:ga57cfb81065d428e618af45cdba5f1f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga9b28065e82cdcee1c320a7120cb8a83d">stan::math::internal::broadcast_array&lt; T &gt;::operator=</a> (const Y &amp;m)</td></tr>
<tr class="memdesc:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can assign any right hand side which allows for indexing to a <a class="el" href="../../d5/dbd/classstan_1_1math_1_1internal_1_1broadcast__array.html">broadcast_array</a>.  <a href="#ga9b28065e82cdcee1c320a7120cb8a83d">More...</a><br /></td></tr>
<tr class="separator:ga9b28065e82cdcee1c320a7120cb8a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0bc34a86c0bb1a9853b36aa4c952a4dc">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga0bc34a86c0bb1a9853b36aa4c952a4dc">More...</a><br /></td></tr>
<tr class="separator:ga0bc34a86c0bb1a9853b36aa4c952a4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga390dff20f30679c8e57ca2c3efe6d766">stan::math::internal::empty_broadcast_array&lt; T, S, Enable &gt;::operator=</a> (const Y &amp;)</td></tr>
<tr class="memdesc:ga390dff20f30679c8e57ca2c3efe6d766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga390dff20f30679c8e57ca2c3efe6d766">More...</a><br /></td></tr>
<tr class="separator:ga390dff20f30679c8e57ca2c3efe6d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gaf06037332423259c9f5fa57c9b72ad3b">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator[]</a> (int)</td></tr>
<tr class="memdesc:gaf06037332423259c9f5fa57c9b72ad3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#gaf06037332423259c9f5fa57c9b72ad3b">More...</a><br /></td></tr>
<tr class="separator:gaf06037332423259c9f5fa57c9b72ad3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80a702889907a3c12704df6c514fcc07"><td class="memItemLeft" align="right" valign="top">ViewElt &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga80a702889907a3c12704df6c514fcc07">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator()</a> (int)</td></tr>
<tr class="memdesc:ga80a702889907a3c12704df6c514fcc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga80a702889907a3c12704df6c514fcc07">More...</a><br /></td></tr>
<tr class="separator:ga80a702889907a3c12704df6c514fcc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501ec44e68851a8396f5f693e35a2e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga501ec44e68851a8396f5f693e35a2e69">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator=</a> (const T_arg &amp;)</td></tr>
<tr class="memdesc:ga501ec44e68851a8396f5f693e35a2e69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga501ec44e68851a8396f5f693e35a2e69">More...</a><br /></td></tr>
<tr class="separator:ga501ec44e68851a8396f5f693e35a2e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84d157dabee552a681aa5e4406b86474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga84d157dabee552a681aa5e4406b86474">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator+=</a> (T_arg)</td></tr>
<tr class="memdesc:ga84d157dabee552a681aa5e4406b86474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga84d157dabee552a681aa5e4406b86474">More...</a><br /></td></tr>
<tr class="separator:ga84d157dabee552a681aa5e4406b86474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50070330d69c12c87811fcaf4e643803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga50070330d69c12c87811fcaf4e643803">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::operator-=</a> (T_arg)</td></tr>
<tr class="memdesc:ga50070330d69c12c87811fcaf4e643803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga50070330d69c12c87811fcaf4e643803">More...</a><br /></td></tr>
<tr class="separator:ga50070330d69c12c87811fcaf4e643803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga8fd58c5861f0ee94465a97f78b2a00f0">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::row</a> (int)</td></tr>
<tr class="memdesc:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga8fd58c5861f0ee94465a97f78b2a00f0">More...</a><br /></td></tr>
<tr class="separator:ga8fd58c5861f0ee94465a97f78b2a00f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga354e6529ea257ab6475be87e7c217ce9"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga354e6529ea257ab6475be87e7c217ce9">stan::math::internal::empty_broadcast_array&lt; ViewElt, T, require_eigen_t&lt; T &gt; &gt;::col</a> (int)</td></tr>
<tr class="memdesc:ga354e6529ea257ab6475be87e7c217ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not implemented so cannot be called.  <a href="#ga354e6529ea257ab6475be87e7c217ce9">More...</a><br /></td></tr>
<tr class="separator:ga354e6529ea257ab6475be87e7c217ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_convertible&lt;T_actual, T_desired&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga0af4c158839e8c4c401e0f7e78bb4dc6">More...</a><br /></td></tr>
<tr class="separator:ga0af4c158839e8c4c401e0f7e78bb4dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;!std::is_convertible&lt;T_actual, T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">stan::math::forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">More...</a><br /></td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              std::is_convertible&lt;T_actual, T_desired&gt;::value &amp;&amp; static_cast&lt;                  int&gt;(T_desired::RowsAtCompileTime)                  == static_cast&lt;int&gt;(T_actual::RowsAtCompileTime)              &amp;&amp; static_cast&lt;int&gt;(T_desired::ColsAtCompileTime)                     == static_cast&lt;int&gt;(T_actual::ColsAtCompileTime)&gt;, typename  = void&gt; </td></tr>
<tr class="memitem:ga385d807274aa40985a59c273d49cf9cd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga385d807274aa40985a59c273d49cf9cd">stan::math::forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga385d807274aa40985a59c273d49cf9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <a href="../../d8/de1/group__type__trait.html#ga385d807274aa40985a59c273d49cf9cd">More...</a><br /></td></tr>
<tr class="separator:ga385d807274aa40985a59c273d49cf9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a1f786a0f0544b5b9b10800518fa161"><td class="memItemLeft" align="right" valign="top">T_return_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#ga1a1f786a0f0544b5b9b10800518fa161">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:ga1a1f786a0f0544b5b9b10800518fa161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#ga1a1f786a0f0544b5b9b10800518fa161">More...</a><br /></td></tr>
<tr class="separator:ga1a1f786a0f0544b5b9b10800518fa161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd89dca2a48f398e759d882af2e62ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/d39/classstan_1_1math_1_1var.html">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/de1/group__type__trait.html#gacd89dca2a48f398e759d882af2e62ddd">stan::math::operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, var &gt;::build</a> (double value)</td></tr>
<tr class="memdesc:gacd89dca2a48f398e759d882af2e62ddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build the node to be stored on the autodiff graph.  <a href="#gacd89dca2a48f398e759d882af2e62ddd">More...</a><br /></td></tr>
<tr class="separator:gacd89dca2a48f398e759d882af2e62ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="gad1046e42476333dc3c08c35bfe420302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1046e42476333dc3c08c35bfe420302">&sect;&nbsp;</a></span>bool_constant</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool B&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gad1046e42476333dc3c08c35bfe420302">stan::bool_constant</a> = typedef std::integral_constant&lt;bool, B&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for structs used for wraps a static constant of bool. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">B</td><td>On true, inherits std::true_type, false is std::false_type </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../d6/dfd/bool__constant_8hpp_source.html">bool_constant.hpp</a>.</p>

</div>
</div>
<a id="ga6c52a0fffdfffc70123211cead9c7dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c52a0fffdfffc70123211cead9c7dbf">&sect;&nbsp;</a></span>complex_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga6c52a0fffdfffc70123211cead9c7dbf">stan::complex_return_t</a> = typedef std::complex&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::complex</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00057">57</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga76542442910faefbee636785a9f34091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76542442910faefbee636785a9f34091">&sect;&nbsp;</a></span>contains_fvar</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga76542442910faefbee636785a9f34091">stan::contains_fvar</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d4/df3/structstan_1_1is__fvar.html">is_fvar</a>&lt;<a class="el" href="../../da/dce/namespacestan.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt;T&gt;&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::true_type when instantiated with at least 1 template parameter that is a fvar. </p>
<p>Extends std::false_type otherwise. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Types to test </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../da/d10/contains__fvar_8hpp_source.html">contains_fvar.hpp</a>.</p>

</div>
</div>
<a id="gaaa1b1eb615a4b1b30b46ef33ace88cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaa1b1eb615a4b1b30b46ef33ace88cdf">&sect;&nbsp;</a></span>contains_std_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaaa1b1eb615a4b1b30b46ef33ace88cdf">stan::contains_std_vector</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d0/db6/structstan_1_1is__std__vector.html">is_std_vector</a>&lt;Ts&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if any types are std vectors. </p>

<p>Definition at line <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../de/dc9/contains__std__vector_8hpp_source.html">contains_std_vector.hpp</a>.</p>

</div>
</div>
<a id="ga4285e1bff93354519204a845b6c5348b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4285e1bff93354519204a845b6c5348b">&sect;&nbsp;</a></span>contains_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga4285e1bff93354519204a845b6c5348b">stan::contains_vector</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d4/d82/structstan_1_1is__vector.html">is_vector</a>&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metaprogram to determine if any of the provided types is a std or eigen vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Types to test </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/d41/contains__vector_8hpp_source.html#l00014">14</a> of file <a class="el" href="../../d2/d41/contains__vector_8hpp_source.html">contains_vector.hpp</a>.</p>

</div>
</div>
<a id="ga880b82cbb2b83ccaba2426e73996b8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga880b82cbb2b83ccaba2426e73996b8bd">&sect;&nbsp;</a></span>is_constant_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga880b82cbb2b83ccaba2426e73996b8bd">stan::is_constant_all</a> = typedef <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt;<a class="el" href="../../d5/d70/structstan_1_1is__constant.html">is_constant</a>&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Metaprogram defining an enum <code>value</code> which is <code>true</code> if all of the type parameters are constant (i.e., primitive types) and <code>false</code> otherwise. </p>

<p>Definition at line <a class="el" href="../../dd/deb/is__constant_8hpp_source.html#l00039">39</a> of file <a class="el" href="../../dd/deb/is__constant_8hpp_source.html">is_constant.hpp</a>.</p>

</div>
</div>
<a id="ga87910dd57a921a668530336311ab4382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87910dd57a921a668530336311ab4382">&sect;&nbsp;</a></span>is_eigen_matrix_or_array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga87910dd57a921a668530336311ab4382">stan::is_eigen_matrix_or_array</a> = typedef <a class="el" href="../../d8/d3d/structstan_1_1math_1_1disjunction.html">math::disjunction</a>&lt;<a class="el" href="../../d8/d54/structstan_1_1is__eigen__matrix.html">is_eigen_matrix</a>&lt;T&gt;, <a class="el" href="../../dc/d22/structstan_1_1is__eigen__array.html">is_eigen_array</a>&lt;T&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a type is an <code>Eigen::Matrix</code> or <code>Eigen::SparseMatrix</code> or <code>Eigen::Array</code> </p>

<p>Definition at line <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html#l00109">109</a> of file <a class="el" href="../../d8/dd8/is__eigen_8hpp_source.html">is_eigen.hpp</a>.</p>

</div>
</div>
<a id="ga0f2252ae22390725feb09d9ea11b7896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f2252ae22390725feb09d9ea11b7896">&sect;&nbsp;</a></span>is_string_convertible</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga0f2252ae22390725feb09d9ea11b7896">stan::is_string_convertible</a> = typedef std::is_convertible&lt;T, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deduces whether type is convertible to string. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to check </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html#l00016">16</a> of file <a class="el" href="../../dc/d4f/is__string__convertible_8hpp_source.html">is_string_convertible.hpp</a>.</p>

</div>
</div>
<a id="ga9d36a4d6158f96c2321b4fbf55243ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d36a4d6158f96c2321b4fbf55243ca8">&sect;&nbsp;</a></span>is_var_or_arithmetic</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga9d36a4d6158f96c2321b4fbf55243ca8">stan::is_var_or_arithmetic</a> = typedef <a class="el" href="../../da/d56/structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt;<a class="el" href="../../dd/d4f/structstan_1_1is__var__or__arithmetic__type.html">is_var_or_arithmetic_type</a>&lt;T&gt;...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extends std::true_type if all the provided types are either var or an arithmetic type, extends std::false_type otherwise. </p>

<p>Definition at line <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d7/dfe/is__var__or__arithmetic_8hpp_source.html">is_var_or_arithmetic.hpp</a>.</p>

</div>
</div>
<a id="gab3412a1caaad7f8eef55a9ee2a0d3921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3412a1caaad7f8eef55a9ee2a0d3921">&sect;&nbsp;</a></span>matrix_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gab3412a1caaad7f8eef55a9ee2a0d3921">stan::matrix_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, -1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00080">80</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga1310fb459dbad72fa5594b6d1eaad959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1310fb459dbad72fa5594b6d1eaad959">&sect;&nbsp;</a></span>partials_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1310fb459dbad72fa5594b6d1eaad959">stan::partials_type_t</a> = typedef typename <a class="el" href="../../d0/db7/structstan_1_1partials__type.html">partials_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper alias for accessing the partial type. </p>

<p>Definition at line <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../dd/d43/prim_2meta_2partials__type_8hpp_source.html">partials_type.hpp</a>.</p>

</div>
</div>
<a id="ga546483131616701876a9f1307f5a413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga546483131616701876a9f1307f5a413d">&sect;&nbsp;</a></span>promote_args_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga546483131616701876a9f1307f5a413d">stan::promote_args_t</a> = typedef typename boost::math::tools::promote_args&lt;Args...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience alias for boost tools promote_args. </p>

<p>Definition at line <a class="el" href="../../de/d54/promote__args_8hpp_source.html#l00012">12</a> of file <a class="el" href="../../de/d54/promote__args_8hpp_source.html">promote_args.hpp</a>.</p>

</div>
</div>
<a id="gac9d3fe14d5102916bf0b5b05712c833e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac9d3fe14d5102916bf0b5b05712c833e">&sect;&nbsp;</a></span>real_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a> = typedef typename <a class="el" href="../../d0/dc1/structstan_1_1real__return.html">real_return</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the real return type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gacbaff683cd2683209e6855e2c7aaeffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbaff683cd2683209e6855e2c7aaeffe">&sect;&nbsp;</a></span>return_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a> = typedef typename <a class="el" href="../../d8/d68/structstan_1_1return__type.html">return_type</a>&lt;Ts...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d8/d68/structstan_1_1return__type.html" title="Template metaprogram to calculate the base scalar return type resulting from promoting all the scalar...">return_type</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00206">206</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga2fa4e21b37c08e6abce2919ac4c2cd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fa4e21b37c08e6abce2919ac4c2cd57">&sect;&nbsp;</a></span>row_vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga2fa4e21b37c08e6abce2919ac4c2cd57">stan::row_vector_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, 1, -1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , 1, -1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gace9d2d5da99a3e14fcadd7bf0f6cffee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9d2d5da99a3e14fcadd7bf0f6cffee">&sect;&nbsp;</a></span>scalar_lub_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gace9d2d5da99a3e14fcadd7bf0f6cffee">stan::scalar_lub_t</a> = typedef typename <a class="el" href="../../d5/d1d/structstan_1_1scalar__lub.html">scalar_lub</a>&lt;T1, T2&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type for the least upper bound of the specified template parameters in Stan's assignment ordering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T1</td><td>first type </td></tr>
    <tr><td class="paramname">T2</td><td>second type </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d1d/structstan_1_1scalar__lub.html" title="Defines a member type named type that is the least scalar type to which both template parameter scala...">scalar_lub</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00147">147</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="gaad4ed0103c48143e708de631fbb83a7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaad4ed0103c48143e708de631fbb83a7f">&sect;&nbsp;</a></span>std_vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#gaad4ed0103c48143e708de631fbb83a7f">stan::std_vector_return_t</a> = typedef std::vector&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>std::vector</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00068">68</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<a id="ga57121ded0440567e8dfb0d80b1290922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57121ded0440567e8dfb0d80b1290922">&sect;&nbsp;</a></span>value_type_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga57121ded0440567e8dfb0d80b1290922">stan::value_type_t</a> = typedef typename <a class="el" href="../../dd/d27/structstan_1_1value__type.html">value_type</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function for accessing underlying type. </p>

<p>Definition at line <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../df/dd4/prim_2meta_2value__type_8hpp_source.html">value_type.hpp</a>.</p>

</div>
</div>
<a id="ga1b070b6ae219eccccf07b44243307b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b070b6ae219eccccf07b44243307b8b">&sect;&nbsp;</a></span>vector_return_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d8/de1/group__type__trait.html#ga1b070b6ae219eccccf07b44243307b8b">stan::vector_return_t</a> = typedef Eigen::Matrix&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt;Ts...&gt;, -1, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience type to calculate the complex return type, which wraps <code>Eigen::Matrix&lt; , -1, 1&gt;</code> around the return type of the specified template parameters. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>sequence of argument types </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d0/dc1/structstan_1_1real__return.html" title="Provides a member type alias named type, the value of which is the least type under Stan&#39;s assignabil...">real_return</a> </dd></dl>

<p>Definition at line <a class="el" href="../../d9/d94/return__type_8hpp_source.html#l00092">92</a> of file <a class="el" href="../../d9/d94/return__type_8hpp_source.html">return_type.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafbc8947aae651b674f5935b7531d7939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbc8947aae651b674f5935b7531d7939">&sect;&nbsp;</a></span>as_array_or_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::as_array_or_scalar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns specified input value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Same value. </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d25/as__array__or__scalar_8hpp_source.html#l00020">20</a> of file <a class="el" href="../../dc/d25/as__array__or__scalar_8hpp_source.html">as_array_or_scalar.hpp</a>.</p>

</div>
</div>
<a id="gad8bd3e9a682f845429678cd1a04986f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8bd3e9a682f845429678cd1a04986f1">&sect;&nbsp;</a></span>as_array_or_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const Eigen::Array&lt;T, Eigen::Dynamic, 1&gt; &gt; stan::math::as_array_or_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a std::vector type to an array. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix converted to an array. </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d25/as__array__or__scalar_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../dc/d25/as__array__or__scalar_8hpp_source.html">as_array_or_scalar.hpp</a>.</p>

</div>
</div>
<a id="ga172517131afb410729d2c7000006b494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga172517131afb410729d2c7000006b494">&sect;&nbsp;</a></span>as_column_vector_or_scalar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::as_column_vector_or_scalar </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts input argument to a column vector or a scalar. </p>
<p>For scalar inputs that is an identity function.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1x1 matrix that contains the value of scalar. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d8a/as__column__vector__or__scalar_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d8/d8a/as__column__vector__or__scalar_8hpp_source.html">as_column_vector_or_scalar.hpp</a>.</p>

</div>
</div>
<a id="ga57cfb81065d428e618af45cdba5f1f99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga57cfb81065d428e618af45cdba5f1f99">&sect;&nbsp;</a></span>as_column_vector_or_scalar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Map&lt;const Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; &gt; stan::math::as_column_vector_or_scalar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts input argument to a column vector or a scalar. </p>
<p>std::vector will be converted to a column vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of scalar element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Specified vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input converted to a column vector. </dd></dl>

<p>Definition at line <a class="el" href="../../d8/d8a/as__column__vector__or__scalar_8hpp_source.html#l00062">62</a> of file <a class="el" href="../../d8/d8a/as__column__vector__or__scalar_8hpp_source.html">as_column_vector_or_scalar.hpp</a>.</p>

</div>
</div>
<a id="gae29786dab3b9274d3f1d08f6904854eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae29786dab3b9274d3f1d08f6904854eb">&sect;&nbsp;</a></span>build() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 , typename Dx &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d7/dcd/classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00_01fvar_3_01_dx_01_4_01_4.html#afce03dc72ef9b35eb9045d3c7b060fd5">T_return_type</a> <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, <a class="el" href="../../d0/dfb/structstan_1_1math_1_1fvar.html">fvar</a>&lt; Dx &gt; &gt;::build </td>
          <td>(</td>
          <td class="paramtype">Dx&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p>Definition at line <a class="el" href="../../d5/da0/fwd_2meta_2operands__and__partials_8hpp_source.html#l00104">104</a> of file <a class="el" href="../../d5/da0/fwd_2meta_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="gacd89dca2a48f398e759d882af2e62ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd89dca2a48f398e759d882af2e62ddd">&sect;&nbsp;</a></span>build() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1 , typename Op2 , typename Op3 , typename Op4 , typename Op5 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/d39/classstan_1_1math_1_1var.html">var</a> <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, <a class="el" href="../../d1/d39/classstan_1_1math_1_1var.html">var</a> &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars, we don't calculate any tangents. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the node to be stored in the expression graph for autodiff </dd></dl>

<p>Definition at line <a class="el" href="../../df/d27/rev_2meta_2operands__and__partials_8hpp_source.html#l00112">112</a> of file <a class="el" href="../../df/d27/rev_2meta_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="ga1a1f786a0f0544b5b9b10800518fa161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a1f786a0f0544b5b9b10800518fa161">&sect;&nbsp;</a></span>build() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Op1, typename Op2, typename Op3, typename Op4, typename Op5, typename T_return_type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_return_type <a class="el" href="../../da/dd1/classstan_1_1math_1_1operands__and__partials.html">stan::math::operands_and_partials</a>&lt; Op1, Op2, Op3, Op4, Op5, T_return_type &gt;::build </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Build the node to be stored on the autodiff graph. </p>
<p>This should contain both the value and the tangent.</p>
<p>For scalars (this implementation), we don't calculate any derivatives. For reverse mode, we end up returning a type of var that will calculate the appropriate adjoint using the stored operands and partials. Forward mode just calculates the tangent on the spot and returns it in a vanilla fvar.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>the return value of the function we are compressing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value with its derivative </dd></dl>

<p>Definition at line <a class="el" href="../../df/d9b/prim_2meta_2operands__and__partials_8hpp_source.html#l00120">120</a> of file <a class="el" href="../../df/d9b/prim_2meta_2operands__and__partials_8hpp_source.html">operands_and_partials.hpp</a>.</p>

</div>
</div>
<a id="ga354e6529ea257ab6475be87e7c217ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga354e6529ea257ab6475be87e7c217ce9">&sect;&nbsp;</a></span>col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::col </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga0af4c158839e8c4c401e0f7e78bb4dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0af4c158839e8c4c401e0f7e78bb4dc6">&sect;&nbsp;</a></span>forward_as() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_convertible&lt;T_actual, T_desired&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="ga6cc77bba018fff06dd1f0f0f2d79e5b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cc77bba018fff06dd1f0f0f2d79e5b9">&sect;&nbsp;</a></span>forward_as() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;!std::is_convertible&lt;T_actual, T_desired&gt;::value&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_desired stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">const T_actual &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is not convertible to assumed type or in case of eigen types compile time rows and columns are not the same this has return type of <code>T_desired</code>, but it only throws. This version should only be used where it is optimized away so the throw should never happen.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nothing, this always throws </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">always</td><td>throws std::runtime_error </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="ga385d807274aa40985a59c273d49cf9cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga385d807274aa40985a59c273d49cf9cd">&sect;&nbsp;</a></span>forward_as() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              std::is_convertible&lt;T_actual, T_desired&gt;::value &amp;&amp; static_cast&lt;                  int&gt;(T_desired::RowsAtCompileTime)                  == static_cast&lt;int&gt;(T_actual::RowsAtCompileTime)              &amp;&amp; static_cast&lt;int&gt;(T_desired::ColsAtCompileTime)                     == static_cast&lt;int&gt;(T_actual::ColsAtCompileTime)&gt;, typename  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T_actual&amp;&amp; stan::math::forward_as </td>
          <td>(</td>
          <td class="paramtype">T_actual &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assume which type we get. </p>
<p>If actual type is convertible to assumed type or in case of eigen types compile time rows and columns also match this is a no-op. Otherwise it throws std::runtime_error, which should never happen if used as intended.</p>
<p>This is intended to be used in compile time branches that would otherwise trigger compile error even though they are never executed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_desired</td><td>type of output we need to avoid compile time errors </td></tr>
    <tr><td class="paramname">T_actual</td><td>actual type of the argument </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input value a </dd></dl>

<p>Definition at line <a class="el" href="../../d1/df7/forward__as_8hpp_source.html#l00078">78</a> of file <a class="el" href="../../d1/df7/forward__as_8hpp_source.html">forward_as.hpp</a>.</p>

</div>
</div>
<a id="gad2a93cdd718b76d4994d0f7c6c05fbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2a93cdd718b76d4994d0f7c6c05fbba">&sect;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the provided element. </p>
<p>Scalar type overload for the function to retrieve n-th element of a vector, <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code> or expression</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input scalar </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>input scalar </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a id="ga431bd201f09a215cccb16cda10a1e840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga431bd201f09a215cccb16cda10a1e840">&sect;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::get </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the n-th element of the provided std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector </td></tr>
    <tr><td class="paramname">n</td><td>index of the element to return </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>n-th element of the input vector </dd></dl>

<p>Definition at line <a class="el" href="../../dc/d95/get_8hpp_source.html#l00035">35</a> of file <a class="el" href="../../dc/d95/get_8hpp_source.html">get.hpp</a>.</p>

</div>
</div>
<a id="ga80a702889907a3c12704df6c514fcc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80a702889907a3c12704df6c514fcc07">&sect;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga84d157dabee552a681aa5e4406b86474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84d157dabee552a681aa5e4406b86474">&sect;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">T_arg&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga50070330d69c12c87811fcaf4e643803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50070330d69c12c87811fcaf4e643803">&sect;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">T_arg&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga9b28065e82cdcee1c320a7120cb8a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b28065e82cdcee1c320a7120cb8a83d">&sect;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d5/dbd/classstan_1_1math_1_1internal_1_1broadcast__array.html">stan::math::internal::broadcast_array</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We can assign any right hand side which allows for indexing to a <a class="el" href="../../d5/dbd/classstan_1_1math_1_1internal_1_1broadcast__array.html">broadcast_array</a>. </p>
<p>The idea is that the entry for the first index is what gets assigned. The most common use-case should be where the rhs is some container of length 1. </p>

<p>Definition at line <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d4/df8/broadcast__array_8hpp_source.html">broadcast_array.hpp</a>.</p>

</div>
</div>
<a id="ga390dff20f30679c8e57ca2c3efe6d766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga390dff20f30679c8e57ca2c3efe6d766">&sect;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename S, typename Enable = void&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga501ec44e68851a8396f5f693e35a2e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga501ec44e68851a8396f5f693e35a2e69">&sect;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const T_arg &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga0bc34a86c0bb1a9853b36aa4c952a4dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bc34a86c0bb1a9853b36aa4c952a4dc">&sect;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename S, typename Enable = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; T, S, Enable &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="gaf06037332423259c9f5fa57c9b72ad3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf06037332423259c9f5fa57c9b72ad3b">&sect;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ViewElt&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="ga8fd58c5861f0ee94465a97f78b2a00f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8fd58c5861f0ee94465a97f78b2a00f0">&sect;&nbsp;</a></span>row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ViewElt , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="../../d3/d28/classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">stan::math::internal::empty_broadcast_array</a>&lt; ViewElt, T, <a class="el" href="../../d1/d91/group__eigen__types.html#ga99a7a1ce2d8f16360ef5ce109f8c3c10">require_eigen_t</a>&lt; T &gt; &gt;::row </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Not implemented so cannot be called. </p>

</div>
</div>
<a id="gafadbbba7194b85b76f6045dcb605351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafadbbba7194b85b76f6045dcb605351f">&sect;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the length of primitive scalar types that are always of length 1. </p>

<p>Definition at line <a class="el" href="../../d1/d10/size_8hpp_source.html#l00017">17</a> of file <a class="el" href="../../d1/d10/size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a id="gaa0cca2c6f7e5fd2ba86713a4057e74d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0cca2c6f7e5fd2ba86713a4057e74d3">&sect;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_not_stan_scalar_t&lt;T&gt;, typename  = void&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the provided <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix, expression or std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>input <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code>, expression or std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of m </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/d10/size_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d1/d10/size_8hpp_source.html">size.hpp</a>.</p>

</div>
</div>
<a id="ga0b84d1b1408266cd9f8a37cbec2766d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b84d1b1408266cd9f8a37cbec2766d6">&sect;&nbsp;</a></span>size_mvt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t stan::math::size_mvt </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the size of a multivariate argument. </p>
<p>This is the default template function. For any scalar type, this will throw an std::invalid_argument exception since a scalar is not a multivariate structure.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type to take size of. The default template function should only match scalars. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>since the type is a scalar. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d2/da6/size__mvt_8hpp_source.html">size_mvt.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
