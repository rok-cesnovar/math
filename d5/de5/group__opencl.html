<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: OpenCL</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../$standoxy.css" rel="stylesheet" type="text/css">
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">3.1.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d5/de5/group__opencl.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a> &#124;
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCL</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:d5/d3e/group__matrix__cl__types"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d3e/group__matrix__cl__types.html">matrix_cl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d2/d3c/group__opencl__kernel__generator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d3c/group__opencl__kernel__generator.html">OpenCL Kernel Generator</a></td></tr>
<tr class="memdesc:d2/d3c/group__opencl__kernel__generator"><td class="mdescLeft">&#160;</td><td class="mdescRight">The OpenCL kernel generator is used to combine multiple matrix operations into a single OpenCL kernel. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:dc/d5d/group__opencl__kernels"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d5d/group__opencl__kernels.html">OpenCL Kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:d6/dbf/matrix__cl_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dbf/matrix__cl_8hpp.html">matrix_cl.hpp</a></td></tr>
<tr class="memdesc:d6/dbf/matrix__cl_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix_cl class - allocates memory space on the OpenCL device, functions for transferring matrices to and from OpenCL devices. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/d1b/opencl__context_8hpp"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d1b/opencl__context_8hpp.html">opencl_context.hpp</a></td></tr>
<tr class="memdesc:d3/d1b/opencl__context_8hpp"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialization for OpenCL: <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dbe/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1to__buffer.html">stan::math::opencl_kernels::internal::to_buffer&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">meta template struct for changing read/write buffer argument types to cl::Buffer types.  <a href="../../d8/dbe/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1to__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/d0d/structstan_1_1internal_1_1is__matrix__cl__impl.html">stan::internal::is_matrix_cl_impl&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This underlying implementation is used when the type is not an std vector.  <a href="../../de/d0d/structstan_1_1internal_1_1is__matrix__cl__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/dc3/structstan_1_1internal_1_1is__matrix__cl__impl_3_01stan_1_1math_1_1matrix__cl_3_01_args_8_8_8_01_4_01_4.html">stan::internal::is_matrix_cl_impl&lt; stan::math::matrix_cl&lt; Args... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization implementation has a static member named value when the template type is an std vector.  <a href="../../d2/dc3/structstan_1_1internal_1_1is__matrix__cl__impl_3_01stan_1_1math_1_1matrix__cl_3_01_args_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/d5a/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1assign__event__helper.html">stan::math::opencl_kernels::internal::assign_event_helper&lt; T, K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for assigning events to a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>.  <a href="../../d4/d5a/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1assign__event__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d1d/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1select__event__helper.html">stan::math::opencl_kernels::internal::select_event_helper&lt; T, K &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to select OpenCL event vectors from an <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>.  <a href="../../dd/d1d/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1select__event__helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/db1/classstan_1_1math_1_1opencl__kernels_1_1kernel__functor.html">stan::math::opencl_kernels::kernel_functor&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor used for compiling kernels.  <a href="../../d6/db1/classstan_1_1math_1_1opencl__kernels_1_1kernel__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">stan::math::opencl_kernels::kernel_cl&lt; Args &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates functor for kernels.  <a href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d94/classstan_1_1math_1_1matrix__cl_3_01_t_00_01require__arithmetic__t_3_01_t_01_4_01_4.html">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix on the OpenCL device.  <a href="../../da/d94/classstan_1_1math_1_1matrix__cl_3_01_t_00_01require__arithmetic__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html">stan::math::opencl_context_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html" title="The opencl_context_base class represents an OpenCL context in the standard Meyers singleton design pa...">opencl_context_base</a></code> class represents an OpenCL context in the standard Meyers singleton design pattern.  <a href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d09/classstan_1_1math_1_1opencl__context.html">stan::math::opencl_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API to access the methods and values in <a class="el" href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html" title="The opencl_context_base class represents an OpenCL context in the standard Meyers singleton design pa...">opencl_context_base</a>.  <a href="../../d9/d09/classstan_1_1math_1_1opencl__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga55b628b5a271afb9f569c34187fd82ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga55b628b5a271afb9f569c34187fd82ad">stan::math::opencl::cholesky_decompose</a> (<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga55b628b5a271afb9f569c34187fd82ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <a href="../../d5/de5/group__opencl.html#ga55b628b5a271afb9f569c34187fd82ad">More...</a><br /></td></tr>
<tr class="separator:ga55b628b5a271afb9f569c34187fd82ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad96a59b0196ef4571bbabb1576d06e59"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Mat_scalar  = scalar_type_t&lt;Mat&gt;, require_eigen_vt&lt; std::is_arithmetic, Mat &gt; ...&gt; </td></tr>
<tr class="memitem:gad96a59b0196ef4571bbabb1576d06e59"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Mat_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad96a59b0196ef4571bbabb1576d06e59">stan::math::to_matrix_cl</a> (Mat &amp;&amp;src)</td></tr>
<tr class="memdesc:gad96a59b0196ef4571bbabb1576d06e59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix to the destination matrix that is stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#gad96a59b0196ef4571bbabb1576d06e59">More...</a><br /></td></tr>
<tr class="separator:gad96a59b0196ef4571bbabb1576d06e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf34ee44f7f6c3329cb71f358f01d34e5"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_std_vector_vt&lt; std::is_arithmetic, Vec &gt; ...&gt; </td></tr>
<tr class="memitem:gaf34ee44f7f6c3329cb71f358f01d34e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf34ee44f7f6c3329cb71f358f01d34e5">stan::math::to_matrix_cl</a> (Vec &amp;&amp;src)</td></tr>
<tr class="memdesc:gaf34ee44f7f6c3329cb71f358f01d34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <code>std::vector</code> to the destination matrix that is stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#gaf34ee44f7f6c3329cb71f358f01d34e5">More...</a><br /></td></tr>
<tr class="separator:gaf34ee44f7f6c3329cb71f358f01d34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92137405557af2d110b4f82887488e71"><td class="memTemplParams" colspan="2">template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga92137405557af2d110b4f82887488e71"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, R, C &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga92137405557af2d110b4f82887488e71">stan::math::from_matrix_cl</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga92137405557af2d110b4f82887488e71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix.  <a href="../../d5/de5/group__opencl.html#ga92137405557af2d110b4f82887488e71">More...</a><br /></td></tr>
<tr class="separator:ga92137405557af2d110b4f82887488e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8613031c3585afb538d2ea250bdd4b55"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga8613031c3585afb538d2ea250bdd4b55"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8613031c3585afb538d2ea250bdd4b55">stan::math::packed_copy</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga8613031c3585afb538d2ea250bdd4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs the flat triangular matrix on the OpenCL device and copies it to the std::vector.  <a href="../../d5/de5/group__opencl.html#ga8613031c3585afb538d2ea250bdd4b55">More...</a><br /></td></tr>
<tr class="separator:ga8613031c3585afb538d2ea250bdd4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; ...&gt; </td></tr>
<tr class="memitem:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">stan::math::packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="../../d4/d84/namespacestan_1_1math.html#abd8dccff7facd64877956505ce8f5fd5">rows</a>)</td></tr>
<tr class="memdesc:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#gaed1f7da1a49ff3c2a9e1147b4eef4662">More...</a><br /></td></tr>
<tr class="separator:gaed1f7da1a49ff3c2a9e1147b4eef4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e2d9354b6ea452bb158131a526ebbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae7e2d9354b6ea452bb158131a526ebbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae7e2d9354b6ea452bb158131a526ebbb">stan::math::copy_cl</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:gae7e2d9354b6ea452bb158131a526ebbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix to the destination matrix.  <a href="../../d5/de5/group__opencl.html#gae7e2d9354b6ea452bb158131a526ebbb">More...</a><br /></td></tr>
<tr class="separator:gae7e2d9354b6ea452bb158131a526ebbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513debd5fdb603fc031e9fd8e7999521"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga513debd5fdb603fc031e9fd8e7999521"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga513debd5fdb603fc031e9fd8e7999521">stan::math::from_matrix_cl_error_code</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga513debd5fdb603fc031e9fd8e7999521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy A 1 by 1 source matrix from the Device to the host.  <a href="../../d5/de5/group__opencl.html#ga513debd5fdb603fc031e9fd8e7999521">More...</a><br /></td></tr>
<tr class="separator:ga513debd5fdb603fc031e9fd8e7999521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d7980457fe59c29a88d7484852051fa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;std::decay_t&lt;T&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga9d7980457fe59c29a88d7484852051fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; std::decay_t&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9d7980457fe59c29a88d7484852051fa">stan::math::to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="memdesc:ga9d7980457fe59c29a88d7484852051fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy an arithmetic type to the device.  <a href="../../d5/de5/group__opencl.html#ga9d7980457fe59c29a88d7484852051fa">More...</a><br /></td></tr>
<tr class="separator:ga9d7980457fe59c29a88d7484852051fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07713dbdc8b5bbcbf7a5ce6071cfc753"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga07713dbdc8b5bbcbf7a5ce6071cfc753"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga07713dbdc8b5bbcbf7a5ce6071cfc753">stan::math::copy_triangular</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga07713dbdc8b5bbcbf7a5ce6071cfc753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the lower or upper triangular of the source matrix to the destination matrix.  <a href="../../d5/de5/group__opencl.html#ga07713dbdc8b5bbcbf7a5ce6071cfc753">More...</a><br /></td></tr>
<tr class="separator:ga07713dbdc8b5bbcbf7a5ce6071cfc753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab67cc8b155df4a4ed24bdfee6d2b3be5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:gab67cc8b155df4a4ed24bdfee6d2b3be5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab67cc8b155df4a4ed24bdfee6d2b3be5">stan::math::diagonal_multiply</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 scalar)</td></tr>
<tr class="memdesc:gab67cc8b155df4a4ed24bdfee6d2b3be5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the diagonal of a matrix on the OpenCL device with the specified scalar.  <a href="../../d5/de5/group__opencl.html#gab67cc8b155df4a4ed24bdfee6d2b3be5">More...</a><br /></td></tr>
<tr class="separator:gab67cc8b155df4a4ed24bdfee6d2b3be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7b45675dbc4a14c5fb27fcac9e303bf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaf7b45675dbc4a14c5fb27fcac9e303bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf7b45675dbc4a14c5fb27fcac9e303bf">stan::math::check_diagonal_zeros</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:gaf7b45675dbc4a14c5fb27fcac9e303bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has zeros on the diagonal.  <a href="../../d5/de5/group__opencl.html#gaf7b45675dbc4a14c5fb27fcac9e303bf">More...</a><br /></td></tr>
<tr class="separator:gaf7b45675dbc4a14c5fb27fcac9e303bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b3141bb5f86cb9f296238fd3afec00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga49b3141bb5f86cb9f296238fd3afec00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga49b3141bb5f86cb9f296238fd3afec00">stan::math::check_invalid_matrix_view</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> invalid_view)</td></tr>
<tr class="memdesc:ga49b3141bb5f86cb9f296238fd3afec00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has an invalid view.  <a href="../../d5/de5/group__opencl.html#ga49b3141bb5f86cb9f296238fd3afec00">More...</a><br /></td></tr>
<tr class="separator:ga49b3141bb5f86cb9f296238fd3afec00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7fddc359d2c9021fe3d800eceece8f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab7fddc359d2c9021fe3d800eceece8f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab7fddc359d2c9021fe3d800eceece8f9">stan::math::check_mat_size_one</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:gab7fddc359d2c9021fe3d800eceece8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has a single element.  <a href="../../d5/de5/group__opencl.html#gab7fddc359d2c9021fe3d800eceece8f9">More...</a><br /></td></tr>
<tr class="separator:gab7fddc359d2c9021fe3d800eceece8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga37fe55b7d7b3c0ae69f331104dcd3d64">stan::math::check_mat_not_size_one</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has a single element.  <a href="../../d5/de5/group__opencl.html#ga37fe55b7d7b3c0ae69f331104dcd3d64">More...</a><br /></td></tr>
<tr class="separator:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135d5fbcdd79597b7e7bf4f48adaba5b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga135d5fbcdd79597b7e7bf4f48adaba5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga135d5fbcdd79597b7e7bf4f48adaba5b">stan::math::check_matching_dims</a> (const char *function, const char *name1, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y1, const char *name2, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y2)</td></tr>
<tr class="memdesc:ga135d5fbcdd79597b7e7bf4f48adaba5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>s have the same dimensions.  <a href="../../d5/de5/group__opencl.html#ga135d5fbcdd79597b7e7bf4f48adaba5b">More...</a><br /></td></tr>
<tr class="separator:ga135d5fbcdd79597b7e7bf4f48adaba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a2b237bbf6ac41be7443b37690cb4c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga87a2b237bbf6ac41be7443b37690cb4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga87a2b237bbf6ac41be7443b37690cb4c">stan::math::check_nan</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ga87a2b237bbf6ac41be7443b37690cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has NaN values.  <a href="../../d5/de5/group__opencl.html#ga87a2b237bbf6ac41be7443b37690cb4c">More...</a><br /></td></tr>
<tr class="separator:ga87a2b237bbf6ac41be7443b37690cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga423364ebfbb176382d94cb3e2786d4cc">stan::math::check_opencl_error</a> (const char *function, const cl::Error &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>)</td></tr>
<tr class="memdesc:ga423364ebfbb176382d94cb3e2786d4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws the domain error with specifying the OpenCL error that occurred.  <a href="../../d5/de5/group__opencl.html#ga423364ebfbb176382d94cb3e2786d4cc">More...</a><br /></td></tr>
<tr class="separator:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7afb555cfe2bae599e11ba7d1a34a9d0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga7afb555cfe2bae599e11ba7d1a34a9d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga7afb555cfe2bae599e11ba7d1a34a9d0">stan::math::check_square</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ga7afb555cfe2bae599e11ba7d1a34a9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is square.  <a href="../../d5/de5/group__opencl.html#ga7afb555cfe2bae599e11ba7d1a34a9d0">More...</a><br /></td></tr>
<tr class="separator:ga7afb555cfe2bae599e11ba7d1a34a9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3ea8fac58afac1cbf0d1351f849dd102">stan::math::check_symmetric</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is symmetric.  <a href="../../d5/de5/group__opencl.html#ga3ea8fac58afac1cbf0d1351f849dd102">More...</a><br /></td></tr>
<tr class="separator:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf93bf4ae9827df053b6c59ff2ec0c130"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf93bf4ae9827df053b6c59ff2ec0c130"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf93bf4ae9827df053b6c59ff2ec0c130">stan::math::check_triangular</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:gaf93bf4ae9827df053b6c59ff2ec0c130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is either upper triangular or lower triangular.  <a href="../../d5/de5/group__opencl.html#gaf93bf4ae9827df053b6c59ff2ec0c130">More...</a><br /></td></tr>
<tr class="separator:gaf93bf4ae9827df053b6c59ff2ec0c130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08e6a117007becde3e2d8ce31c7f8d4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga08e6a117007becde3e2d8ce31c7f8d4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga08e6a117007becde3e2d8ce31c7f8d4a">stan::math::check_vector</a> (const char *function, const char *name, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ga08e6a117007becde3e2d8ce31c7f8d4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrix is either a row vector or column vector.  <a href="../../d5/de5/group__opencl.html#ga08e6a117007becde3e2d8ce31c7f8d4a">More...</a><br /></td></tr>
<tr class="separator:ga08e6a117007becde3e2d8ce31c7f8d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d66a071139027ac3de753839511f7f8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5d66a071139027ac3de753839511f7f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5d66a071139027ac3de753839511f7f8">stan::math::identity</a> (int rows_cols)</td></tr>
<tr class="memdesc:ga5d66a071139027ac3de753839511f7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the identity matrix stored on the OpenCL device.  <a href="../../d5/de5/group__opencl.html#ga5d66a071139027ac3de753839511f7f8">More...</a><br /></td></tr>
<tr class="separator:ga5d66a071139027ac3de753839511f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5621902e224a5a5392177af1277d440"><td class="memTemplParams" colspan="2">template&lt;typename T , typename K  = double&gt; </td></tr>
<tr class="memitem:gad5621902e224a5a5392177af1277d440"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad5621902e224a5a5392177af1277d440">stan::math::opencl_kernels::internal::get_kernel_args</a> (const T &amp;t)</td></tr>
<tr class="memdesc:gad5621902e224a5a5392177af1277d440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the kernel's arguments, used in the global and local kernel constructor.  <a href="../../d5/de5/group__opencl.html#gad5621902e224a5a5392177af1277d440">More...</a><br /></td></tr>
<tr class="separator:gad5621902e224a5a5392177af1277d440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bebcf5695e7745e939955d1748c2c52"><td class="memTemplParams" colspan="2">template&lt;typename K &gt; </td></tr>
<tr class="memitem:ga8bebcf5695e7745e939955d1748c2c52"><td class="memTemplItemLeft" align="right" valign="top">const cl::Buffer &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8bebcf5695e7745e939955d1748c2c52">stan::math::opencl_kernels::internal::get_kernel_args</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;m)</td></tr>
<tr class="memdesc:ga8bebcf5695e7745e939955d1748c2c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the kernel's arguments, used in the global and local kernel constructor.  <a href="../../d5/de5/group__opencl.html#ga8bebcf5695e7745e939955d1748c2c52">More...</a><br /></td></tr>
<tr class="separator:ga8bebcf5695e7745e939955d1748c2c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa774e31398b590ca1564e7f0ec8ffe63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa774e31398b590ca1564e7f0ec8ffe63">stan::math::opencl_kernels::internal::assign_event_helper&lt; T, K &gt;::set</a> (const cl::Event &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;m)</td></tr>
<tr class="memdesc:gaa774e31398b590ca1564e7f0ec8ffe63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the event to the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>.  <a href="#gaa774e31398b590ca1564e7f0ec8ffe63">More...</a><br /></td></tr>
<tr class="separator:gaa774e31398b590ca1564e7f0ec8ffe63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69d3eac49b859fa73316f720f8c20884"><td class="memTemplParams" colspan="2">template&lt;typename T , typename K  = double&gt; </td></tr>
<tr class="memitem:ga69d3eac49b859fa73316f720f8c20884"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga69d3eac49b859fa73316f720f8c20884">stan::math::opencl_kernels::internal::assign_event</a> (const cl::Event &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, const T &amp;)</td></tr>
<tr class="memdesc:ga69d3eac49b859fa73316f720f8c20884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the event to a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>.  <a href="../../d5/de5/group__opencl.html#ga69d3eac49b859fa73316f720f8c20884">More...</a><br /></td></tr>
<tr class="separator:ga69d3eac49b859fa73316f720f8c20884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed1c43f3e3eb169d6f2a6dbb6341779d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename K &gt; </td></tr>
<tr class="memitem:gaed1c43f3e3eb169d6f2a6dbb6341779d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaed1c43f3e3eb169d6f2a6dbb6341779d">stan::math::opencl_kernels::internal::assign_event</a> (const cl::Event &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a3b650a0131d41167ef4837ecc7d02be5">e</a>, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;m)</td></tr>
<tr class="memdesc:gaed1c43f3e3eb169d6f2a6dbb6341779d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns the event to a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>.  <a href="../../d5/de5/group__opencl.html#gaed1c43f3e3eb169d6f2a6dbb6341779d">More...</a><br /></td></tr>
<tr class="separator:gaed1c43f3e3eb169d6f2a6dbb6341779d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0a60799ae54fb39d221a9265c48fe4"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename... Args, typename CallArg , typename... CallArgs&gt; </td></tr>
<tr class="memitem:ga0a0a60799ae54fb39d221a9265c48fe4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0a0a60799ae54fb39d221a9265c48fe4">stan::math::opencl_kernels::internal::assign_events</a> (const cl::Event &amp;new_event, CallArg &amp;m, CallArgs &amp;... args)</td></tr>
<tr class="memdesc:ga0a0a60799ae54fb39d221a9265c48fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the event to any <code>matrix_cls</code> in the arguments depending on whether they are <code><a class="el" href="../../d4/db4/structstan_1_1math_1_1opencl__kernels_1_1in__buffer.html">in_buffer</a></code>, <code><a class="el" href="../../d7/d46/structstan_1_1math_1_1opencl__kernels_1_1out__buffer.html">out_buffer</a></code>, or <code>in_out_buffers</code>.  <a href="../../d5/de5/group__opencl.html#ga0a0a60799ae54fb39d221a9265c48fe4">More...</a><br /></td></tr>
<tr class="separator:ga0a0a60799ae54fb39d221a9265c48fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81b531a8000a627662cc92ea71bc78e1"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cl::Event &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga81b531a8000a627662cc92ea71bc78e1">stan::math::opencl_kernels::internal::select_event_helper&lt; T, K &gt;::get</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ga81b531a8000a627662cc92ea71bc78e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the events from a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>.  <a href="#ga81b531a8000a627662cc92ea71bc78e1">More...</a><br /></td></tr>
<tr class="separator:ga81b531a8000a627662cc92ea71bc78e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f28e6eca7f3ab2b173f9b605db66805"><td class="memTemplParams" colspan="2">template&lt;typename T , typename K  = double&gt; </td></tr>
<tr class="memitem:ga3f28e6eca7f3ab2b173f9b605db66805"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; cl::Event &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3f28e6eca7f3ab2b173f9b605db66805">stan::math::opencl_kernels::internal::select_events</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ga3f28e6eca7f3ab2b173f9b605db66805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Select events from kernel arguments.  <a href="../../d5/de5/group__opencl.html#ga3f28e6eca7f3ab2b173f9b605db66805">More...</a><br /></td></tr>
<tr class="separator:ga3f28e6eca7f3ab2b173f9b605db66805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ad2c3d1e332959bca1499f0982e3f41"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4ad2c3d1e332959bca1499f0982e3f41">stan::math::opencl_kernels::compile_kernel</a> (const char *name, const std::vector&lt; std::string &gt; &amp;sources, std::map&lt; std::string, int &gt; &amp;options)</td></tr>
<tr class="memdesc:ga4ad2c3d1e332959bca1499f0982e3f41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile an OpenCL kernel.  <a href="../../d5/de5/group__opencl.html#ga4ad2c3d1e332959bca1499f0982e3f41">More...</a><br /></td></tr>
<tr class="separator:ga4ad2c3d1e332959bca1499f0982e3f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ec264557a0c4ca29d63c29116042516"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1ec264557a0c4ca29d63c29116042516">stan::math::opencl_kernels::kernel_functor&lt; Args &gt;::kernel_functor</a> (const char *name, const std::vector&lt; std::string &gt; &amp;sources, const std::map&lt; std::string, int &gt; &amp;options)</td></tr>
<tr class="memdesc:ga1ec264557a0c4ca29d63c29116042516"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor to access the kernel compiler.  <a href="#ga1ec264557a0c4ca29d63c29116042516">More...</a><br /></td></tr>
<tr class="separator:ga1ec264557a0c4ca29d63c29116042516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad618bb355838ab832cb4cd42b563de32"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad618bb355838ab832cb4cd42b563de32">stan::math::opencl_kernels::kernel_functor&lt; Args &gt;::get_opts</a> () const</td></tr>
<tr class="separator:gad618bb355838ab832cb4cd42b563de32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad597780e2807177349094d71040c79b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad597780e2807177349094d71040c79b7">stan::math::opencl_kernels::kernel_cl&lt; Args &gt;::kernel_cl</a> (const char *name, const std::vector&lt; std::string &gt; &amp;sources, const std::map&lt; std::string, int &gt; &amp;options={})</td></tr>
<tr class="memdesc:gad597780e2807177349094d71040c79b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates functor for kernels that only need access to defining the global work size.  <a href="#gad597780e2807177349094d71040c79b7">More...</a><br /></td></tr>
<tr class="separator:gad597780e2807177349094d71040c79b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4645f90b937230d0a8ed0772c80d582f"><td class="memTemplParams" colspan="2">template&lt;typename... CallArgs&gt; </td></tr>
<tr class="memitem:ga4645f90b937230d0a8ed0772c80d582f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4645f90b937230d0a8ed0772c80d582f">stan::math::opencl_kernels::kernel_cl&lt; Args &gt;::operator()</a> (cl::NDRange global_thread_size, const CallArgs &amp;... args) const</td></tr>
<tr class="memdesc:ga4645f90b937230d0a8ed0772c80d582f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a kernel.  <a href="#ga4645f90b937230d0a8ed0772c80d582f">More...</a><br /></td></tr>
<tr class="separator:ga4645f90b937230d0a8ed0772c80d582f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912062e483d281d341511cb52b6e8986"><td class="memTemplParams" colspan="2">template&lt;typename... CallArgs&gt; </td></tr>
<tr class="memitem:ga912062e483d281d341511cb52b6e8986"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga912062e483d281d341511cb52b6e8986">stan::math::opencl_kernels::kernel_cl&lt; Args &gt;::operator()</a> (cl::NDRange global_thread_size, cl::NDRange thread_block_size, const CallArgs &amp;... args) const</td></tr>
<tr class="memdesc:ga912062e483d281d341511cb52b6e8986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes a kernel.  <a href="#ga912062e483d281d341511cb52b6e8986">More...</a><br /></td></tr>
<tr class="separator:ga912062e483d281d341511cb52b6e8986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6585fe09d1feeca2af78de1527c1ab3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gab6585fe09d1feeca2af78de1527c1ab3">stan::math::opencl_kernels::kernel_cl&lt; Args &gt;::get_option</a> (const std::string option_name) const</td></tr>
<tr class="memdesc:gab6585fe09d1feeca2af78de1527c1ab3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves an option used for compiling the kernel.  <a href="#gab6585fe09d1feeca2af78de1527c1ab3">More...</a><br /></td></tr>
<tr class="separator:gab6585fe09d1feeca2af78de1527c1ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f82755da6ae91980b6422caca095fb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2f82755da6ae91980b6422caca095fb7">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::clear_write_events</a> () const</td></tr>
<tr class="memdesc:ga2f82755da6ae91980b6422caca095fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the write events from the event stacks.  <a href="#ga2f82755da6ae91980b6422caca095fb7">More...</a><br /></td></tr>
<tr class="separator:ga2f82755da6ae91980b6422caca095fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ca2fac9e39e7f5b2857b4147d8ff249"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3ca2fac9e39e7f5b2857b4147d8ff249">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::clear_read_events</a> () const</td></tr>
<tr class="memdesc:ga3ca2fac9e39e7f5b2857b4147d8ff249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the read events from the event stacks.  <a href="#ga3ca2fac9e39e7f5b2857b4147d8ff249">More...</a><br /></td></tr>
<tr class="separator:ga3ca2fac9e39e7f5b2857b4147d8ff249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ad346d6d82f389d85f21cdea98e252e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2ad346d6d82f389d85f21cdea98e252e">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::clear_read_write_events</a> () const</td></tr>
<tr class="memdesc:ga2ad346d6d82f389d85f21cdea98e252e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the write events from the event stacks.  <a href="#ga2ad346d6d82f389d85f21cdea98e252e">More...</a><br /></td></tr>
<tr class="separator:ga2ad346d6d82f389d85f21cdea98e252e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga253726d88d973fc5857da4789f966ead"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cl::Event &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga253726d88d973fc5857da4789f966ead">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::write_events</a> () const</td></tr>
<tr class="memdesc:ga253726d88d973fc5857da4789f966ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the events from the event stacks.  <a href="#ga253726d88d973fc5857da4789f966ead">More...</a><br /></td></tr>
<tr class="separator:ga253726d88d973fc5857da4789f966ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108943105e9393ccfcc5a823fd09fef5"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cl::Event &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga108943105e9393ccfcc5a823fd09fef5">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::read_events</a> () const</td></tr>
<tr class="memdesc:ga108943105e9393ccfcc5a823fd09fef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the events from the event stacks.  <a href="#ga108943105e9393ccfcc5a823fd09fef5">More...</a><br /></td></tr>
<tr class="separator:ga108943105e9393ccfcc5a823fd09fef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6bf57efead4194de30b7e77ef83ec9"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; cl::Event &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaac6bf57efead4194de30b7e77ef83ec9">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::read_write_events</a> () const</td></tr>
<tr class="memdesc:gaac6bf57efead4194de30b7e77ef83ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the events from the event stacks.  <a href="#gaac6bf57efead4194de30b7e77ef83ec9">More...</a><br /></td></tr>
<tr class="separator:gaac6bf57efead4194de30b7e77ef83ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67b2d1f8cdd2b5b0cd24d9e08d4648bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga67b2d1f8cdd2b5b0cd24d9e08d4648bb">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::add_read_event</a> (cl::Event new_event) const</td></tr>
<tr class="memdesc:ga67b2d1f8cdd2b5b0cd24d9e08d4648bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event to the read event stack.  <a href="#ga67b2d1f8cdd2b5b0cd24d9e08d4648bb">More...</a><br /></td></tr>
<tr class="separator:ga67b2d1f8cdd2b5b0cd24d9e08d4648bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6989c5c983e1f44666dde72273daf465"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6989c5c983e1f44666dde72273daf465">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::add_write_event</a> (cl::Event new_event) const</td></tr>
<tr class="memdesc:ga6989c5c983e1f44666dde72273daf465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event to the write event stack.  <a href="#ga6989c5c983e1f44666dde72273daf465">More...</a><br /></td></tr>
<tr class="separator:ga6989c5c983e1f44666dde72273daf465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga388ee4a91452ad8131ea4ec8869945f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga388ee4a91452ad8131ea4ec8869945f0">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::add_read_write_event</a> (cl::Event new_event) const</td></tr>
<tr class="memdesc:ga388ee4a91452ad8131ea4ec8869945f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event to the read/write event stack.  <a href="#ga388ee4a91452ad8131ea4ec8869945f0">More...</a><br /></td></tr>
<tr class="separator:ga388ee4a91452ad8131ea4ec8869945f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b954f61c3febc8c94948323c6af1a66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::wait_for_write_events</a> () const</td></tr>
<tr class="memdesc:ga2b954f61c3febc8c94948323c6af1a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the write events and clears the read event stack.  <a href="#ga2b954f61c3febc8c94948323c6af1a66">More...</a><br /></td></tr>
<tr class="separator:ga2b954f61c3febc8c94948323c6af1a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9952ba849d1603dd6eba78fc0ee16a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga3e9952ba849d1603dd6eba78fc0ee16a">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::wait_for_read_events</a> () const</td></tr>
<tr class="memdesc:ga3e9952ba849d1603dd6eba78fc0ee16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for the read events and clears the read event stack.  <a href="#ga3e9952ba849d1603dd6eba78fc0ee16a">More...</a><br /></td></tr>
<tr class="separator:ga3e9952ba849d1603dd6eba78fc0ee16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5e337c8923957cfbb050b50e49c515b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::wait_for_read_write_events</a> () const</td></tr>
<tr class="memdesc:gae5e337c8923957cfbb050b50e49c515b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for read and write events to finish and clears the read, write, and read/write event stacks.  <a href="#gae5e337c8923957cfbb050b50e49c515b">More...</a><br /></td></tr>
<tr class="separator:gae5e337c8923957cfbb050b50e49c515b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5be704a0cd4c3a7c9717a6a930d9001f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5be704a0cd4c3a7c9717a6a930d9001f">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (cl::Buffer &amp;A, const int R, const int C, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:ga5be704a0cd4c3a7c9717a6a930d9001f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix_cl&lt;T&gt; from an existing cl::Buffer object.  <a href="#ga5be704a0cd4c3a7c9717a6a930d9001f">More...</a><br /></td></tr>
<tr class="separator:ga5be704a0cd4c3a7c9717a6a930d9001f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ffd2c2a8a15f15579c3fd69f2415d7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6ffd2c2a8a15f15579c3fd69f2415d7d">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (const int <a class="el" href="../../da/d94/classstan_1_1math_1_1matrix__cl_3_01_t_00_01require__arithmetic__t_3_01_t_01_4_01_4.html#af19515826901ef24d71ffea250e7d44c">rows</a>, const int <a class="el" href="../../da/d94/classstan_1_1math_1_1matrix__cl_3_01_t_00_01require__arithmetic__t_3_01_t_01_4_01_4.html#ac889c59fd2b776a428d807d462ca7bf0">cols</a>, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:ga6ffd2c2a8a15f15579c3fd69f2415d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that only allocates the buffer on the OpenCL device.  <a href="#ga6ffd2c2a8a15f15579c3fd69f2415d7d">More...</a><br /></td></tr>
<tr class="separator:ga6ffd2c2a8a15f15579c3fd69f2415d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbc5231d87818fc567c46c4679516a4c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , require_eigen_t&lt; Mat &gt; ..., require_vt_same&lt; Mat, T &gt; ..., require_not_t&lt; is_eigen_contiguous_map&lt; Mat &gt;&gt; ...&gt; </td></tr>
<tr class="memitem:gacbc5231d87818fc567c46c4679516a4c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gacbc5231d87818fc567c46c4679516a4c">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (Mat &amp;&amp;A, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:gacbc5231d87818fc567c46c4679516a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix or <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> expression on the OpenCL device.  <a href="#gacbc5231d87818fc567c46c4679516a4c">More...</a><br /></td></tr>
<tr class="separator:gacbc5231d87818fc567c46c4679516a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23ab84676726550311b0cf097c0ac3fb"><td class="memTemplParams" colspan="2">template&lt;typename Map , require_t&lt; is_eigen_contiguous_map&lt; Map &gt;&gt; ..., require_vt_same&lt; Map, T &gt; ...&gt; </td></tr>
<tr class="memitem:ga23ab84676726550311b0cf097c0ac3fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga23ab84676726550311b0cf097c0ac3fb">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (Map &amp;&amp;A, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:ga23ab84676726550311b0cf097c0ac3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Map on the OpenCL device.  <a href="#ga23ab84676726550311b0cf097c0ac3fb">More...</a><br /></td></tr>
<tr class="separator:ga23ab84676726550311b0cf097c0ac3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c16ea14247274ea2dd67596b732f391"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename  = require_same_t&lt;T, std::remove_reference_t&lt;Scal&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga6c16ea14247274ea2dd67596b732f391"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6c16ea14247274ea2dd67596b732f391">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (Scal &amp;&amp;A, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a9ac677ee4eec25d9e59707a661d2c5e1">matrix_cl_view::Diagonal</a>)</td></tr>
<tr class="memdesc:ga6c16ea14247274ea2dd67596b732f391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of a scalar on the OpenCL device.  <a href="#ga6c16ea14247274ea2dd67596b732f391">More...</a><br /></td></tr>
<tr class="separator:ga6c16ea14247274ea2dd67596b732f391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f048017726c3bfaa802da6c79ec0cb3"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_std_vector_t&lt; Vec &gt; ..., require_vt_same&lt; Vec, T &gt; ...&gt; </td></tr>
<tr class="memitem:ga8f048017726c3bfaa802da6c79ec0cb3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga8f048017726c3bfaa802da6c79ec0cb3">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (Vec &amp;&amp;A, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:ga8f048017726c3bfaa802da6c79ec0cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> of size Nx1 from <code>std::vector</code>.  <a href="#ga8f048017726c3bfaa802da6c79ec0cb3">More...</a><br /></td></tr>
<tr class="separator:ga8f048017726c3bfaa802da6c79ec0cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad815ea4c357160c8309d33a6c386bedd"><td class="memTemplParams" colspan="2">template&lt;typename Vec , require_std_vector_t&lt; Vec &gt; ..., require_vt_same&lt; Vec, T &gt; ...&gt; </td></tr>
<tr class="memitem:gad815ea4c357160c8309d33a6c386bedd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad815ea4c357160c8309d33a6c386bedd">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (Vec &amp;&amp;A, const int &amp;R, const int &amp;C, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:gad815ea4c357160c8309d33a6c386bedd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <code>std::vector</code> with given rows and columns.  <a href="#gad815ea4c357160c8309d33a6c386bedd">More...</a><br /></td></tr>
<tr class="separator:gad815ea4c357160c8309d33a6c386bedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3f877e59b334af2ea8825a15ee4e575"><td class="memTemplParams" colspan="2">template&lt;typename U , require_same_t&lt; T, U &gt; ...&gt; </td></tr>
<tr class="memitem:gad3f877e59b334af2ea8825a15ee4e575"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad3f877e59b334af2ea8825a15ee4e575">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::matrix_cl</a> (const U *A, const int &amp;R, const int &amp;C, <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> partial_view=<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a>)</td></tr>
<tr class="memdesc:gad3f877e59b334af2ea8825a15ee4e575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <code>array</code> with given rows and columns.  <a href="#gad3f877e59b334af2ea8825a15ee4e575">More...</a><br /></td></tr>
<tr class="separator:gad3f877e59b334af2ea8825a15ee4e575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c532b6185c0b35491a2db6718456152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6c532b6185c0b35491a2db6718456152">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::operator=</a> (<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&amp;a)</td></tr>
<tr class="memdesc:ga6c532b6185c0b35491a2db6718456152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#ga6c532b6185c0b35491a2db6718456152">More...</a><br /></td></tr>
<tr class="separator:ga6c532b6185c0b35491a2db6718456152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423fbbcc22da659e6e8a1167a9549440"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga423fbbcc22da659e6e8a1167a9549440">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::operator=</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga423fbbcc22da659e6e8a1167a9549440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ga423fbbcc22da659e6e8a1167a9549440">More...</a><br /></td></tr>
<tr class="separator:ga423fbbcc22da659e6e8a1167a9549440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9850bbd8d516b87d722ad54947bb9c9f">stan::math::either</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <a href="../../d5/de5/group__opencl.html#ga9850bbd8d516b87d722ad54947bb9c9f">More...</a><br /></td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga338a285d4ba933ba6aa7240908919e0f">stan::math::both</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga338a285d4ba933ba6aa7240908919e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <a href="../../d5/de5/group__opencl.html#ga338a285d4ba933ba6aa7240908919e0f">More...</a><br /></td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadd63c8a601189c916c8a2157066adb7c">stan::math::contains_nonzero</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="memdesc:gadd63c8a601189c916c8a2157066adb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <a href="../../d5/de5/group__opencl.html#gadd63c8a601189c916c8a2157066adb7c">More...</a><br /></td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gafccee2b081b9edd7c6e6d211157e5490">stan::math::transpose</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:gafccee2b081b9edd7c6e6d211157e5490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a view - swaps lower and upper parts.  <a href="../../d5/de5/group__opencl.html#gafccee2b081b9edd7c6e6d211157e5490">More...</a><br /></td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga747f014e58d824281b725a7d4868dd77">stan::math::invert</a> (const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:ga747f014e58d824281b725a7d4868dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a view.  <a href="../../d5/de5/group__opencl.html#ga747f014e58d824281b725a7d4868dd77">More...</a><br /></td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga27e938e6fdd621c5903cc37401c54909">stan::math::from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="memdesc:ga27e938e6fdd621c5903cc37401c54909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view from <code>Eigen::UpLoType</code>.  <a href="../../d5/de5/group__opencl.html#ga27e938e6fdd621c5903cc37401c54909">More...</a><br /></td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae46253a70141bc9eef9e6fe5bf278b78">stan::math::either</a> (int left_view, int right_view)</td></tr>
<tr class="memdesc:gae46253a70141bc9eef9e6fe5bf278b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <a href="../../d5/de5/group__opencl.html#gae46253a70141bc9eef9e6fe5bf278b78">More...</a><br /></td></tr>
<tr class="separator:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4e1f78a060854c0ee5eaf42a9eb21cd5">stan::math::both</a> (int left_view, int right_view)</td></tr>
<tr class="memdesc:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <a href="../../d5/de5/group__opencl.html#ga4e1f78a060854c0ee5eaf42a9eb21cd5">More...</a><br /></td></tr>
<tr class="separator:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga6329dbb31a5e13ede128e993ceb1093f">stan::math::contains_nonzero</a> (int view, int part)</td></tr>
<tr class="memdesc:ga6329dbb31a5e13ede128e993ceb1093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <a href="../../d5/de5/group__opencl.html#ga6329dbb31a5e13ede128e993ceb1093f">More...</a><br /></td></tr>
<tr class="separator:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1797f2d54fbce7486c5080ce2b036824"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga1797f2d54fbce7486c5080ce2b036824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1797f2d54fbce7486c5080ce2b036824">stan::math::opencl::multiply</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ga1797f2d54fbce7486c5080ce2b036824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices.  <a href="../../d5/de5/group__opencl.html#ga1797f2d54fbce7486c5080ce2b036824">More...</a><br /></td></tr>
<tr class="separator:ga1797f2d54fbce7486c5080ce2b036824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga72e3539ba6e81a0a69e69f09c683252a">stan::math::multiply_transpose</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga72e3539ba6e81a0a69e69f09c683252a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a square OpenCL matrix with its transpose.  <a href="../../d5/de5/group__opencl.html#ga72e3539ba6e81a0a69e69f09c683252a">More...</a><br /></td></tr>
<tr class="separator:ga72e3539ba6e81a0a69e69f09c683252a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0abf3a6cd27dacb3635306bd15400c7b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga0abf3a6cd27dacb3635306bd15400c7b">stan::math::opencl_context::description</a> () const</td></tr>
<tr class="memdesc:ga0abf3a6cd27dacb3635306bd15400c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of the OpenCL platform and device that is used.  <a href="#ga0abf3a6cd27dacb3635306bd15400c7b">More...</a><br /></td></tr>
<tr class="separator:ga0abf3a6cd27dacb3635306bd15400c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga032dc81fadf203368960c96ab7e76c5e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga032dc81fadf203368960c96ab7e76c5e">stan::math::opencl_context::capabilities</a> () const</td></tr>
<tr class="memdesc:ga032dc81fadf203368960c96ab7e76c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of the OpenCL platforms and devices that are available.  <a href="#ga032dc81fadf203368960c96ab7e76c5e">More...</a><br /></td></tr>
<tr class="separator:ga032dc81fadf203368960c96ab7e76c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafcde1e1fdb26f89e02d208e383c4f88"><td class="memItemLeft" align="right" valign="top">cl::Context &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaafcde1e1fdb26f89e02d208e383c4f88">stan::math::opencl_context::context</a> ()</td></tr>
<tr class="memdesc:gaafcde1e1fdb26f89e02d208e383c4f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference to the OpenCL context.  <a href="#gaafcde1e1fdb26f89e02d208e383c4f88">More...</a><br /></td></tr>
<tr class="separator:gaafcde1e1fdb26f89e02d208e383c4f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4205ef2a3b5546a9c8b9c23377b43a16"><td class="memItemLeft" align="right" valign="top">cl::CommandQueue &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga4205ef2a3b5546a9c8b9c23377b43a16">stan::math::opencl_context::queue</a> ()</td></tr>
<tr class="memdesc:ga4205ef2a3b5546a9c8b9c23377b43a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reference to the active OpenCL command queue for the device.  <a href="#ga4205ef2a3b5546a9c8b9c23377b43a16">More...</a><br /></td></tr>
<tr class="separator:ga4205ef2a3b5546a9c8b9c23377b43a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27cb13015fc72e11c60c484efc99b360"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html#a3e2468169e35e0b41b1ff3bef0b5ffb0">opencl_context_base::map_base_opts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga27cb13015fc72e11c60c484efc99b360">stan::math::opencl_context::base_opts</a> ()</td></tr>
<tr class="memdesc:ga27cb13015fc72e11c60c484efc99b360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the map of kernel defines.  <a href="#ga27cb13015fc72e11c60c484efc99b360">More...</a><br /></td></tr>
<tr class="separator:ga27cb13015fc72e11c60c484efc99b360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50bc37f3375c76b0c793a0fcc0fe3eaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga50bc37f3375c76b0c793a0fcc0fe3eaa">stan::math::opencl_context::max_thread_block_size</a> ()</td></tr>
<tr class="memdesc:ga50bc37f3375c76b0c793a0fcc0fe3eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum thread block size defined by CL_DEVICE_MAX_WORK_GROUP_SIZE for the device in the context.  <a href="#ga50bc37f3375c76b0c793a0fcc0fe3eaa">More...</a><br /></td></tr>
<tr class="separator:ga50bc37f3375c76b0c793a0fcc0fe3eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae215f1e6c88ed2690ae6c608689d5c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../db/d9c/structstan_1_1math_1_1opencl__context__base_1_1tuning__struct.html">opencl_context_base::tuning_struct</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae215f1e6c88ed2690ae6c608689d5c11">stan::math::opencl_context::tuning_opts</a> ()</td></tr>
<tr class="memdesc:gae215f1e6c88ed2690ae6c608689d5c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thread block size for the Cholesky Decompositions L_11.  <a href="#gae215f1e6c88ed2690ae6c608689d5c11">More...</a><br /></td></tr>
<tr class="separator:gae215f1e6c88ed2690ae6c608689d5c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bb1b9b8761d4399186745bb2d30664c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cl::Device &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2bb1b9b8761d4399186745bb2d30664c">stan::math::opencl_context::device</a> ()</td></tr>
<tr class="memdesc:ga2bb1b9b8761d4399186745bb2d30664c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the OpenCL device used to create the context.  <a href="#ga2bb1b9b8761d4399186745bb2d30664c">More...</a><br /></td></tr>
<tr class="separator:ga2bb1b9b8761d4399186745bb2d30664c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga625a1a3adc98d4d40402fdab8ff2fee5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; cl::Platform &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga625a1a3adc98d4d40402fdab8ff2fee5">stan::math::opencl_context::platform</a> ()</td></tr>
<tr class="memdesc:ga625a1a3adc98d4d40402fdab8ff2fee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector containing the OpenCL platform used to create the context.  <a href="#ga625a1a3adc98d4d40402fdab8ff2fee5">More...</a><br /></td></tr>
<tr class="separator:ga625a1a3adc98d4d40402fdab8ff2fee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10949ed56755b1c2b5f57573026f347f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga10949ed56755b1c2b5f57573026f347f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga10949ed56755b1c2b5f57573026f347f">stan::math::bernoulli_logit_glm_lpmf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="memdesc:ga10949ed56755b1c2b5f57573026f347f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <a href="../../d5/de5/group__opencl.html#ga10949ed56755b1c2b5f57573026f347f">More...</a><br /></td></tr>
<tr class="separator:ga10949ed56755b1c2b5f57573026f347f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2890ad1b7d164482ada6dcf5b0d90482"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_alpha_scalar , typename T_beta_scalar &gt; </td></tr>
<tr class="memitem:ga2890ad1b7d164482ada6dcf5b0d90482"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_alpha_scalar, T_beta_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga2890ad1b7d164482ada6dcf5b0d90482">stan::math::categorical_logit_glm_lpmf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const Eigen::Matrix&lt; T_alpha_scalar, Eigen::Dynamic, 1 &gt; &amp;alpha, const Eigen::Matrix&lt; T_beta_scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="memdesc:ga2890ad1b7d164482ada6dcf5b0d90482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <a href="../../d5/de5/group__opencl.html#ga2890ad1b7d164482ada6dcf5b0d90482">More...</a><br /></td></tr>
<tr class="separator:ga2890ad1b7d164482ada6dcf5b0d90482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9dc086d26daac255e9c18dc5216d99c1">stan::math::divide_columns</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ga9dc086d26daac255e9c18dc5216d99c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a vector.  <a href="../../d5/de5/group__opencl.html#ga9dc086d26daac255e9c18dc5216d99c1">More...</a><br /></td></tr>
<tr class="separator:ga9dc086d26daac255e9c18dc5216d99c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gadbf223f44b8e6a13e709c0179127fa8f">stan::math::divide_columns</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="memdesc:gadbf223f44b8e6a13e709c0179127fa8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a scalar.  <a href="../../d5/de5/group__opencl.html#gadbf223f44b8e6a13e709c0179127fa8f">More...</a><br /></td></tr>
<tr class="separator:gadbf223f44b8e6a13e709c0179127fa8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:gaa686087fcae5e7016b355ceb3cf45846"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaa686087fcae5e7016b355ceb3cf45846">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gaa686087fcae5e7016b355ceb3cf45846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <a href="../../d5/de5/group__opencl.html#gaa686087fcae5e7016b355ceb3cf45846">More...</a><br /></td></tr>
<tr class="separator:gaa686087fcae5e7016b355ceb3cf45846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9ebc1c13865b66015a0f30739b18b28f">stan::math::gp_exp_quad_cov</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga9ebc1c13865b66015a0f30739b18b28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <a href="../../d5/de5/group__opencl.html#ga9ebc1c13865b66015a0f30739b18b28f">More...</a><br /></td></tr>
<tr class="separator:ga9ebc1c13865b66015a0f30739b18b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf44651e3e529d18cba46f4a693383af0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:gaf44651e3e529d18cba46f4a693383af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaf44651e3e529d18cba46f4a693383af0">stan::math::neg_binomial_2_log_glm_lpmf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="memdesc:gaf44651e3e529d18cba46f4a693383af0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <a href="../../d5/de5/group__opencl.html#gaf44651e3e529d18cba46f4a693383af0">More...</a><br /></td></tr>
<tr class="separator:gaf44651e3e529d18cba46f4a693383af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8424b464454c363620c990897ef2988"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:gad8424b464454c363620c990897ef2988"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gad8424b464454c363620c990897ef2988">stan::math::normal_id_glm_lpdf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gad8424b464454c363620c990897ef2988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <a href="../../d5/de5/group__opencl.html#gad8424b464454c363620c990897ef2988">More...</a><br /></td></tr>
<tr class="separator:gad8424b464454c363620c990897ef2988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga95d7f07bfe2244b8eb5a8132f18b4729"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta_scalar , typename T_cuts_scalar &gt; </td></tr>
<tr class="memitem:ga95d7f07bfe2244b8eb5a8132f18b4729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_beta_scalar, T_cuts_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga95d7f07bfe2244b8eb5a8132f18b4729">stan::math::ordered_logistic_glm_lpmf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const Eigen::Matrix&lt; T_beta_scalar, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>, const Eigen::Matrix&lt; T_cuts_scalar, Eigen::Dynamic, 1 &gt; &amp;cuts)</td></tr>
<tr class="memdesc:ga95d7f07bfe2244b8eb5a8132f18b4729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <a href="../../d5/de5/group__opencl.html#ga95d7f07bfe2244b8eb5a8132f18b4729">More...</a><br /></td></tr>
<tr class="separator:ga95d7f07bfe2244b8eb5a8132f18b4729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga599f61cbbaa77aff34e9dd7e44946298"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga599f61cbbaa77aff34e9dd7e44946298"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga599f61cbbaa77aff34e9dd7e44946298">stan::math::poisson_log_glm_lpmf</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;y_cl, const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;x_cl, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="../../d4/d84/namespacestan_1_1math.html#a7c292999da7b2d1eb7a5b3d94f75525a">beta</a>)</td></tr>
<tr class="memdesc:ga599f61cbbaa77aff34e9dd7e44946298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <a href="../../d5/de5/group__opencl.html#ga599f61cbbaa77aff34e9dd7e44946298">More...</a><br /></td></tr>
<tr class="separator:ga599f61cbbaa77aff34e9dd7e44946298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga480e7b2d228e7bb71d6160c87349464a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga480e7b2d228e7bb71d6160c87349464a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga480e7b2d228e7bb71d6160c87349464a">stan::math::rep_matrix</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="memdesc:ga480e7b2d228e7bb71d6160c87349464a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga480e7b2d228e7bb71d6160c87349464a">More...</a><br /></td></tr>
<tr class="separator:ga480e7b2d228e7bb71d6160c87349464a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga9619e09e2ee9450bbcc70f11a8076668">stan::math::rep_matrix</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga9619e09e2ee9450bbcc70f11a8076668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> by replicating the input vector or row_vector.  <a href="../../d5/de5/group__opencl.html#ga9619e09e2ee9450bbcc70f11a8076668">More...</a><br /></td></tr>
<tr class="separator:ga9619e09e2ee9450bbcc70f11a8076668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f940240b9c947f73f5871c9fbaed378"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5f940240b9c947f73f5871c9fbaed378"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga5f940240b9c947f73f5871c9fbaed378">stan::math::rep_row_vector</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga5f940240b9c947f73f5871c9fbaed378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> representing a row_vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga5f940240b9c947f73f5871c9fbaed378">More...</a><br /></td></tr>
<tr class="separator:ga5f940240b9c947f73f5871c9fbaed378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1c5cacb7a3b780ce375aec0449229e03">stan::math::rep_vector</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga1c5cacb7a3b780ce375aec0449229e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> representing a vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>.  <a href="../../d5/de5/group__opencl.html#ga1c5cacb7a3b780ce375aec0449229e03">More...</a><br /></td></tr>
<tr class="separator:ga1c5cacb7a3b780ce375aec0449229e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf49d35bbb3fe115e5183971fba5ddad"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaf49d35bbb3fe115e5183971fba5ddad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaaf49d35bbb3fe115e5183971fba5ddad">stan::math::tri_inverse</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:gaaf49d35bbb3fe115e5183971fba5ddad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a triangular matrix.  <a href="../../d5/de5/group__opencl.html#gaaf49d35bbb3fe115e5183971fba5ddad">More...</a><br /></td></tr>
<tr class="separator:gaaf49d35bbb3fe115e5183971fba5ddad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba77ee14ccb6e86a8dd7f83aa0fe94d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gaba77ee14ccb6e86a8dd7f83aa0fe94d2">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::sub_block</a> (const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt;&gt; &amp;A, size_t A_i, size_t A_j, size_t this_i, size_t this_j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:gaba77ee14ccb6e86a8dd7f83aa0fe94d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of A into <code>this</code> starting at the top left of <code>this</code>  <a href="#gaba77ee14ccb6e86a8dd7f83aa0fe94d2">More...</a><br /></td></tr>
<tr class="separator:gaba77ee14ccb6e86a8dd7f83aa0fe94d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9d851223d1e89198e00e4b0436389d6"><td class="memTemplParams" colspan="2">template&lt;TriangularMapCL triangular_map = TriangularMapCL::LowerToUpper&gt; </td></tr>
<tr class="memitem:gae9d851223d1e89198e00e4b0436389d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gae9d851223d1e89198e00e4b0436389d6">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::triangular_transpose</a> ()</td></tr>
<tr class="memdesc:gae9d851223d1e89198e00e4b0436389d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the lower/upper triangle of a matrix to its upper/lower triangle.  <a href="#gae9d851223d1e89198e00e4b0436389d6">More...</a><br /></td></tr>
<tr class="separator:gae9d851223d1e89198e00e4b0436389d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe035fb9b34a567b1fee336285485ac"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire&gt; </td></tr>
<tr class="memitem:ga1fe035fb9b34a567b1fee336285485ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#ga1fe035fb9b34a567b1fee336285485ac">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::zeros</a> ()</td></tr>
<tr class="memdesc:ga1fe035fb9b34a567b1fee336285485ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zeros in the matrix on the OpenCL device.  <a href="#ga1fe035fb9b34a567b1fee336285485ac">More...</a><br /></td></tr>
<tr class="separator:ga1fe035fb9b34a567b1fee336285485ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc7229e0fe73c06f93cdd8116180c9d6"><td class="memTemplParams" colspan="2">template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire&gt; </td></tr>
<tr class="memitem:gafc7229e0fe73c06f93cdd8116180c9d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d5/de5/group__opencl.html#gafc7229e0fe73c06f93cdd8116180c9d6">stan::math::matrix_cl&lt; T, require_arithmetic_t&lt; T &gt; &gt;::zeros_strict_tri</a> ()</td></tr>
<tr class="memdesc:gafc7229e0fe73c06f93cdd8116180c9d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores zeros in the strict's triangular part (excluding the diagonal) of a matrix on the OpenCL device.  <a href="#gafc7229e0fe73c06f93cdd8116180c9d6">More...</a><br /></td></tr>
<tr class="separator:gafc7229e0fe73c06f93cdd8116180c9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gad597780e2807177349094d71040c79b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad597780e2807177349094d71040c79b7">&sect;&nbsp;</a></span>kernel_cl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">stan::math::opencl_kernels::kernel_cl</a>&lt; Args &gt;::<a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">kernel_cl</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates functor for kernels that only need access to defining the global work size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the kernel </td></tr>
    <tr><td class="paramname">sources</td><td>A std::vector of strings containing the code for the kernel. </td></tr>
    <tr><td class="paramname">options</td><td>The values of macros to be passed at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00295">295</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga1ec264557a0c4ca29d63c29116042516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ec264557a0c4ca29d63c29116042516">&sect;&nbsp;</a></span>kernel_functor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/db1/classstan_1_1math_1_1opencl__kernels_1_1kernel__functor.html">stan::math::opencl_kernels::kernel_functor</a>&lt; Args &gt;::<a class="el" href="../../d6/db1/classstan_1_1math_1_1opencl__kernels_1_1kernel__functor.html">kernel_functor</a> </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; std::string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>functor to access the kernel compiler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the kernel. </td></tr>
    <tr><td class="paramname">sources</td><td>A std::vector of strings containing the code for the kernel. </td></tr>
    <tr><td class="paramname">options</td><td>The values of macros to be passed at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00259">259</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga5be704a0cd4c3a7c9717a6a930d9001f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5be704a0cd4c3a7c9717a6a930d9001f">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">cl::Buffer &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix_cl&lt;T&gt; from an existing cl::Buffer object. </p>
<p>The matrix directly uses given buffer - no copying is done.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the cl::Buffer object to construct the matrix from </td></tr>
    <tr><td class="paramname">R</td><td>number of rows </td></tr>
    <tr><td class="paramname">C</td><td>number of columns </td></tr>
    <tr><td class="paramname">partial_view</td><td>view of the matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00184">184</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga6ffd2c2a8a15f15579c3fd69f2415d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ffd2c2a8a15f15579c3fd69f2415d7d">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that only allocates the buffer on the OpenCL device. </p>
<p>Regardless of <code>partial_view</code>, whole matrix is stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows</td><td>number of matrix rows, must be greater or equal to 0 </td></tr>
    <tr><td class="paramname">cols</td><td>number of matrix columns, must be greater or equal to 0 </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00269">269</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="gacbc5231d87818fc567c46c4679516a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbc5231d87818fc567c46c4679516a4c">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Mat , require_eigen_t&lt; Mat &gt; ..., require_vt_same&lt; Mat, T &gt; ..., require_not_t&lt; is_eigen_contiguous_map&lt; Mat &gt;&gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix or <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> expression on the OpenCL device. </p>
<p>Regardless of <code>partial_view</code>, whole matrix is stored. If a lvalue matrix is passed to this constructor the caller must make sure that the matrix does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Mat</td><td>type of <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code> or expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code> or expression </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00305">305</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga23ab84676726550311b0cf097c0ac3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23ab84676726550311b0cf097c0ac3fb">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Map , require_t&lt; is_eigen_contiguous_map&lt; Map &gt;&gt; ..., require_vt_same&lt; Map, T &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">Map &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> Map on the OpenCL device. </p>
<p>Regardless of <code>partial_view</code>, whole matrix is stored. The caller must make sure that the memory referenced by map is not deleted before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of data in the <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Matrix</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the <code><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a></code> <code>Map</code> </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00351">351</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga6c16ea14247274ea2dd67596b732f391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c16ea14247274ea2dd67596b732f391">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Scal , typename  = require_same_t&lt;T, std::remove_reference_t&lt;Scal&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">Scal &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a9ac677ee4eec25d9e59707a661d2c5e1">matrix_cl_view::Diagonal</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> that creates a copy of a scalar on the OpenCL device. </p>
<p>Regardless of <code>partial_view</code>, whole matrix is stored. If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>the scalar </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00376">376</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga8f048017726c3bfaa802da6c79ec0cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f048017726c3bfaa802da6c79ec0cb3">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Vec , require_std_vector_t&lt; Vec &gt; ..., require_vt_same&lt; Vec, T &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> of size Nx1 from <code>std::vector</code>. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Standard vector </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00400">400</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="gad815ea4c357160c8309d33a6c386bedd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad815ea4c357160c8309d33a6c386bedd">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename Vec , require_std_vector_t&lt; Vec &gt; ..., require_vt_same&lt; Vec, T &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <code>std::vector</code> with given rows and columns. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Standard vector </td></tr>
    <tr><td class="paramname">R</td><td>Number of rows the matrix should have. </td></tr>
    <tr><td class="paramname">C</td><td>Number of columns the matrix should have. </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00424">424</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="gad3f877e59b334af2ea8825a15ee4e575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3f877e59b334af2ea8825a15ee4e575">&sect;&nbsp;</a></span>matrix_cl() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U , require_same_t&lt; T, U &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::<a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td>
          <td>(</td>
          <td class="paramtype">const U *&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>R</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>partial_view</em> = <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">matrix_cl_view::Entire</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from <code>array</code> with given rows and columns. </p>
<p>The caller must make sure that data is not deleted before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.<a class="el" href="../../d5/de5/group__opencl.html#ga2b954f61c3febc8c94948323c6af1a66" title="Waits for the write events and clears the read event stack. ">wait_for_write_events()</a></code> or <code>.<a class="el" href="../../d5/de5/group__opencl.html#gae5e337c8923957cfbb050b50e49c515b" title="Waits for read and write events to finish and clears the read, write, and read/write event stacks...">wait_for_read_write_events()</a></code> on this matrix or any matrix that is calculated from this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>array of doubles </td></tr>
    <tr><td class="paramname">R</td><td>Number of rows the matrix should have. </td></tr>
    <tr><td class="paramname">C</td><td>Number of columns the matrix should have. </td></tr>
    <tr><td class="paramname">partial_view</td><td>which part of the matrix is used</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::system_error&lt;/code&gt;</td><td>if the memory on the device could not be allocated </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00448">448</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga67b2d1f8cdd2b5b0cd24d9e08d4648bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga67b2d1f8cdd2b5b0cd24d9e08d4648bb">&sect;&nbsp;</a></span>add_read_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::add_read_event </td>
          <td>(</td>
          <td class="paramtype">cl::Event&#160;</td>
          <td class="paramname"><em>new_event</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event to the read event stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_event</td><td>The event to be pushed on the event stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00121">121</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga388ee4a91452ad8131ea4ec8869945f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga388ee4a91452ad8131ea4ec8869945f0">&sect;&nbsp;</a></span>add_read_write_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::add_read_write_event </td>
          <td>(</td>
          <td class="paramtype">cl::Event&#160;</td>
          <td class="paramname"><em>new_event</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event to the read/write event stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_event</td><td>The event to be pushed on the event stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00137">137</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga6989c5c983e1f44666dde72273daf465"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6989c5c983e1f44666dde72273daf465">&sect;&nbsp;</a></span>add_write_event()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::add_write_event </td>
          <td>(</td>
          <td class="paramtype">cl::Event&#160;</td>
          <td class="paramname"><em>new_event</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an event to the write event stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_event</td><td>The event to be pushed on the event stack. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00129">129</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga69d3eac49b859fa73316f720f8c20884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69d3eac49b859fa73316f720f8c20884">&sect;&nbsp;</a></span>assign_event() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl_kernels::internal::assign_event </td>
          <td>(</td>
          <td class="paramtype">const cl::Event &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the event to a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to be assigned, if not a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> this function will do nothing. </td></tr>
    <tr><td class="paramname">K</td><td>The type of the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event to be assigned. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00099">99</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gaed1c43f3e3eb169d6f2a6dbb6341779d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1c43f3e3eb169d6f2a6dbb6341779d">&sect;&nbsp;</a></span>assign_event() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl_kernels::internal::assign_event </td>
          <td>(</td>
          <td class="paramtype">const cl::Event &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the event to a <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to be assigned, if not a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> will do nothing. </td></tr>
    <tr><td class="paramname">K</td><td>The type of the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>The event to be assigned. </td></tr>
    <tr><td class="paramname">m</td><td>The <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to be assigned </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00109">109</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga0a0a60799ae54fb39d221a9265c48fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0a60799ae54fb39d221a9265c48fe4">&sect;&nbsp;</a></span>assign_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Arg , typename... Args, typename CallArg , typename... CallArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl_kernels::internal::assign_events </td>
          <td>(</td>
          <td class="paramtype">const cl::Event &amp;&#160;</td>
          <td class="paramname"><em>new_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallArg &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallArgs &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the event to any <code>matrix_cls</code> in the arguments depending on whether they are <code><a class="el" href="../../d4/db4/structstan_1_1math_1_1opencl__kernels_1_1in__buffer.html">in_buffer</a></code>, <code><a class="el" href="../../d7/d46/structstan_1_1math_1_1opencl__kernels_1_1out__buffer.html">out_buffer</a></code>, or <code>in_out_buffers</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arg</td><td>Arguments given during kernel creation that specify the kernel signature. </td></tr>
    <tr><td class="paramname">Args</td><td>Arguments given during kernel creation that specify the kernel signature. </td></tr>
    <tr><td class="paramname">CallArg</td><td>First argument type used to call the kernel </td></tr>
    <tr><td class="paramname">CallArgs</td><td>Other argument types used to call the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_event</td><td>The cl::Event generated involving the arguments. </td></tr>
    <tr><td class="paramname">m</td><td>Arguments to the kernel that may be <code>matrix_cls</code> or not. Non-matrices are ignored. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to the kernel that may be matrices or not. Non-matrices are ignored. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00135">135</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga27cb13015fc72e11c60c484efc99b360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27cb13015fc72e11c60c484efc99b360">&sect;&nbsp;</a></span>base_opts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d1/de9/classstan_1_1math_1_1opencl__context__base.html#a3e2468169e35e0b41b1ff3bef0b5ffb0">opencl_context_base::map_base_opts</a> stan::math::opencl_context::base_opts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a copy of the map of kernel defines. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00341">341</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga10949ed56755b1c2b5f57573026f347f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10949ed56755b1c2b5f57573026f347f">&sect;&nbsp;</a></span>bernoulli_logit_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_alpha , typename T_beta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_alpha, T_beta&gt; stan::math::bernoulli_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../d2/d4c/prim_2prob_2bernoulli__logit__glm__lpmf_8hpp.html">prim/prob/bernoulli_logit_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>binary scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is not binary. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html#l00046">46</a> of file <a class="el" href="../../d6/dfd/opencl_2prim_2bernoulli__logit__glm__lpmf_8hpp_source.html">bernoulli_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga338a285d4ba933ba6aa7240908919e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga338a285d4ba933ba6aa7240908919e0f">&sect;&nbsp;</a></span>both() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::both </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in both input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>common nonzero part </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00032">32</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga4e1f78a060854c0ee5eaf42a9eb21cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e1f78a060854c0ee5eaf42a9eb21cd5">&sect;&nbsp;</a></span>both() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::both </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in both input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>common nonzero part </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00115">115</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga032dc81fadf203368960c96ab7e76c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga032dc81fadf203368960c96ab7e76c5e">&sect;&nbsp;</a></span>capabilities()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::math::opencl_context::capabilities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of the OpenCL platforms and devices that are available. </p>
<p>Devices will be an OpenCL and Platforms are a specific OpenCL implementation such as AMD SDK's or Nvidia's OpenCL implementation. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00262">262</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga2890ad1b7d164482ada6dcf5b0d90482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2890ad1b7d164482ada6dcf5b0d90482">&sect;&nbsp;</a></span>categorical_logit_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_alpha_scalar , typename T_beta_scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_alpha_scalar, T_beta_scalar&gt; stan::math::categorical_logit_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_alpha_scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_beta_scalar, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../df/d55/prim_2prob_2categorical__logit__glm__lpmf_8hpp.html">prim/prob/categorical_logit_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha_scalar</td><td>type of scalar in the intercept vector </td></tr>
    <tr><td class="paramname">T_beta_scalar</td><td>type of a scalar in the matrix of weights </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>a scalar or vector of classes. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept vector (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>x, beta or alpha is infinite or y is not within bounds </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d5/d91/opencl_2prim_2categorical__logit__glm__lpmf_8hpp_source.html">categorical_logit_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gaf7b45675dbc4a14c5fb27fcac9e303bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7b45675dbc4a14c5fb27fcac9e303bf">&sect;&nbsp;</a></span>check_diagonal_zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_diagonal_zeros </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has zeros on the diagonal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if any diagonal element of the matrix is zero. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/d33/err_2check__diagonal__zeros_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d4/d33/err_2check__diagonal__zeros_8hpp_source.html">check_diagonal_zeros.hpp</a>.</p>

</div>
</div>
<a id="ga49b3141bb5f86cb9f296238fd3afec00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49b3141bb5f86cb9f296238fd3afec00">&sect;&nbsp;</a></span>check_invalid_matrix_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_invalid_matrix_view </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>invalid_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has an invalid view. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test </td></tr>
    <tr><td class="paramname">invalid_view</td><td>the view that is not allowed</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> size is not 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/dd4/check__invalid__matrix__view_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d2/dd4/check__invalid__matrix__view_8hpp_source.html">check_invalid_matrix_view.hpp</a>.</p>

</div>
</div>
<a id="ga37fe55b7d7b3c0ae69f331104dcd3d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37fe55b7d7b3c0ae69f331104dcd3d64">&sect;&nbsp;</a></span>check_mat_not_size_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_mat_not_size_one </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has a single element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> size is not 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/da7/check__mat__size__one_8hpp_source.html#l00041">41</a> of file <a class="el" href="../../d5/da7/check__mat__size__one_8hpp_source.html">check_mat_size_one.hpp</a>.</p>

</div>
</div>
<a id="gab7fddc359d2c9021fe3d800eceece8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab7fddc359d2c9021fe3d800eceece8f9">&sect;&nbsp;</a></span>check_mat_size_one()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_mat_size_one </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has a single element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> size is not 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/da7/check__mat__size__one_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d5/da7/check__mat__size__one_8hpp_source.html">check_mat_size_one.hpp</a>.</p>

</div>
</div>
<a id="ga135d5fbcdd79597b7e7bf4f48adaba5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga135d5fbcdd79597b7e7bf4f48adaba5b">&sect;&nbsp;</a></span>check_matching_dims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_matching_dims </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>s have the same dimensions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name1</td><td>Variable name for the first matrix (for error messages) </td></tr>
    <tr><td class="paramname">y1</td><td>First <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> </td></tr>
    <tr><td class="paramname">name2</td><td>Variable name for the second matrix (for error messages) </td></tr>
    <tr><td class="paramname">y2</td><td>Second <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the dimensions of the matrices do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d42/opencl_2err_2check__matching__dims_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dd/d42/opencl_2err_2check__matching__dims_8hpp_source.html">check_matching_dims.hpp</a>.</p>

</div>
</div>
<a id="ga87a2b237bbf6ac41be7443b37690cb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87a2b237bbf6ac41be7443b37690cb4c">&sect;&nbsp;</a></span>check_nan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_nan </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> has NaN values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if any element of the matrix is <code>NaN</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d4a/err_2check__nan_8hpp_source.html#l00026">26</a> of file <a class="el" href="../../dd/d4a/err_2check__nan_8hpp_source.html">check_nan.hpp</a>.</p>

</div>
</div>
<a id="ga423364ebfbb176382d94cb3e2786d4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423364ebfbb176382d94cb3e2786d4cc">&sect;&nbsp;</a></span>check_opencl_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_opencl_error </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const cl::Error &amp;&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throws the domain error with specifying the OpenCL error that occurred. </p>
<p>It outputs the OpenCL errors that are specified in OpenCL 2.0. If no matching error number is found, it throws the error with the number. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>the name of the function where the error occurred </td></tr>
    <tr><td class="paramname">e</td><td>The error number </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d9/dba/check__opencl_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../d9/dba/check__opencl_8hpp_source.html">check_opencl.hpp</a>.</p>

</div>
</div>
<a id="ga7afb555cfe2bae599e11ba7d1a34a9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7afb555cfe2bae599e11ba7d1a34a9d0">&sect;&nbsp;</a></span>check_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_square </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is square. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d8/db0/opencl_2err_2check__square_8hpp_source.html#l00021">21</a> of file <a class="el" href="../../d8/db0/opencl_2err_2check__square_8hpp_source.html">check_square.hpp</a>.</p>

</div>
</div>
<a id="ga3ea8fac58afac1cbf0d1351f849dd102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ea8fac58afac1cbf0d1351f849dd102">&sect;&nbsp;</a></span>check_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_symmetric </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is symmetric. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">y</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::domain_error&lt;/code&gt;</td><td>if the matrix is not symmetric. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/d43/opencl_2err_2check__symmetric_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d5/d43/opencl_2err_2check__symmetric_8hpp_source.html">check_symmetric.hpp</a>.</p>

</div>
</div>
<a id="gaf93bf4ae9827df053b6c59ff2ec0c130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf93bf4ae9827df053b6c59ff2ec0c130">&sect;&nbsp;</a></span>check_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_triangular </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is either upper triangular or lower triangular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">A</td><td><code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> is not triangular </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d90/check__triangular_8hpp_source.html#l00023">23</a> of file <a class="el" href="../../dd/d90/check__triangular_8hpp_source.html">check_triangular.hpp</a>.</p>

</div>
</div>
<a id="ga08e6a117007becde3e2d8ce31c7f8d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08e6a117007becde3e2d8ce31c7f8d4a">&sect;&nbsp;</a></span>check_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::check_vector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the matrix is either a row vector or column vector. </p>
<p>This function checks the runtime size of the matrix to check whether it is a row or column vector. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type of the matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Function name (for error messages) </td></tr>
    <tr><td class="paramname">name</td><td>Variable name (for error messages) </td></tr>
    <tr><td class="paramname">x</td><td>Matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if x is not a row or column vector. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d3/dac/opencl_2err_2check__vector_8hpp_source.html#l00027">27</a> of file <a class="el" href="../../d3/dac/opencl_2err_2check__vector_8hpp_source.html">check_vector.hpp</a>.</p>

</div>
</div>
<a id="ga55b628b5a271afb9f569c34187fd82ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55b628b5a271afb9f569c34187fd82ad">&sect;&nbsp;</a></span>cholesky_decompose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::opencl::cholesky_decompose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs an in-place computation of the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix. </p>
<p>The return value \(L\) will be a lower-triangular matrix such that the original matrix \(A\) is given by </p>
<p>\(A = L \times L^T\). The Cholesky decomposition is computed using an OpenCL kernel. This algorithm is recursive. The matrix is subset into a matrix of size <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#abd8dccff7facd64877956505ce8f5fd5" title="Return the number of rows in the specified matrix, vector, or row vector. ">A.rows()</a> / 4</code>, and if the submatrix size is less than 50 or <code>min_block</code> then the Cholesky decomposition on the OpenCL device is computed using that submatrix. If the submatrix is greater than 50 or <code>min_block</code> then <code>cholesky_decompose</code> is run again on a submatrix with size equal to <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#abd8dccff7facd64877956505ce8f5fd5" title="Return the number of rows in the specified matrix, vector, or row vector. ">submat.rows()</a> / 4</code>. Once the Cholesky decomposition is computed, the full matrix Cholesky is created by propagating the Cholesky forward as given in the reference report below.</p>
<p>For a full guide to how this works see the Cholesky decomposition chapter in the reference report <a href="https://goo.gl/6kWkJ5">here</a>. </p><dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if m is not positive definite (if m has more than 0 elements) </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html#l00043">43</a> of file <a class="el" href="../../d7/df1/opencl_2cholesky__decompose_8hpp_source.html">cholesky_decompose.hpp</a>.</p>

</div>
</div>
<a id="ga3ca2fac9e39e7f5b2857b4147d8ff249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ca2fac9e39e7f5b2857b4147d8ff249">&sect;&nbsp;</a></span>clear_read_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::clear_read_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the read events from the event stacks. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00079">79</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga2ad346d6d82f389d85f21cdea98e252e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ad346d6d82f389d85f21cdea98e252e">&sect;&nbsp;</a></span>clear_read_write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::clear_read_write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the write events from the event stacks. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00087">87</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga2f82755da6ae91980b6422caca095fb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f82755da6ae91980b6422caca095fb7">&sect;&nbsp;</a></span>clear_write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::clear_write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the write events from the event stacks. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00071">71</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga4ad2c3d1e332959bca1499f0982e3f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ad2c3d1e332959bca1499f0982e3f41">&sect;&nbsp;</a></span>compile_kernel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto stan::math::opencl_kernels::compile_kernel </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; std::string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compile an OpenCL kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name for the kernel </td></tr>
    <tr><td class="paramname">sources</td><td>A std::vector of strings containing the code for the kernel. </td></tr>
    <tr><td class="paramname">options</td><td>The values of macros to be passed at compile time. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00215">215</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gadd63c8a601189c916c8a2157066adb7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd63c8a601189c916c8a2157066adb7c">&sect;&nbsp;</a></span>contains_nonzero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::contains_nonzero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a view contains certain nonzero part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to check </td></tr>
    <tr><td class="paramname">part</td><td>part to check for (usually <code>Lower</code> or <code>Upper</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if <code>view</code> has <code>part</code> nonzero </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga6329dbb31a5e13ede128e993ceb1093f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6329dbb31a5e13ede128e993ceb1093f">&sect;&nbsp;</a></span>contains_nonzero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool stan::math::contains_nonzero </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a view contains certain nonzero part. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to check </td></tr>
    <tr><td class="paramname">part</td><td>part to check for (usually <code>Lower</code> or <code>Upper</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if <code>view</code> has <code>part</code> nonzero </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00123">123</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="gaafcde1e1fdb26f89e02d208e383c4f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafcde1e1fdb26f89e02d208e383c4f88">&sect;&nbsp;</a></span>context()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::Context&amp; stan::math::opencl_context::context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reference to the OpenCL context. </p>
<p>The OpenCL context manages objects such as the device, memory, command queue, program, and kernel objects. For stan, there should only be one context, queue, device, and program with multiple kernels. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00327">327</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="gae7e2d9354b6ea452bb158131a526ebbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7e2d9354b6ea452bb158131a526ebbb">&sect;&nbsp;</a></span>copy_cl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; stan::math::copy_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source matrix to the destination matrix. </p>
<p>Both matrices are stored on the OpenCL device.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with copies of values in the source matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00201">201</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga07713dbdc8b5bbcbf7a5ce6071cfc753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07713dbdc8b5bbcbf7a5ce6071cfc753">&sect;&nbsp;</a></span>copy_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::copy_triangular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the lower or upper triangular of the source matrix to the destination matrix. </p>
<p>Both matrices are stored on the OpenCL device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">triangular_map</td><td>int to describe which part of the matrix to copy: <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">matrix_cl_view::Lower</a> - copies the lower triangular <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a19de5b94f7b83900d4b296d9fa491aec">matrix_cl_view::Upper</a> - copes the upper triangular</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix with the copied content </dd></dl>

<p>Definition at line <a class="el" href="../../df/db3/copy__triangular_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../df/db3/copy__triangular_8hpp_source.html">copy_triangular.hpp</a>.</p>

</div>
</div>
<a id="ga0abf3a6cd27dacb3635306bd15400c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0abf3a6cd27dacb3635306bd15400c7b">&sect;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string stan::math::opencl_context::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description of the OpenCL platform and device that is used. </p>
<p>Devices will be an OpenCL and Platforms are a specific OpenCL implementation such as AMD SDK's or Nvidia's OpenCL implementation. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00206">206</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga2bb1b9b8761d4399186745bb2d30664c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2bb1b9b8761d4399186745bb2d30664c">&sect;&nbsp;</a></span>device()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cl::Device&gt; stan::math::opencl_context::device </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the OpenCL device used to create the context. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00365">365</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="gab67cc8b155df4a4ed24bdfee6d2b3be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab67cc8b155df4a4ed24bdfee6d2b3be5">&sect;&nbsp;</a></span>diagonal_multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2&gt; &gt; stan::math::diagonal_multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>scalar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Multiplies the diagonal of a matrix on the OpenCL device with the specified scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">scalar</td><td>scalar </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of the input matrix with the diagonal multiplied by scalar </dd></dl>

<p>Definition at line <a class="el" href="../../d4/d93/diagonal__multiply_8hpp_source.html#l00022">22</a> of file <a class="el" href="../../d4/d93/diagonal__multiply_8hpp_source.html">diagonal_multiply.hpp</a>.</p>

</div>
</div>
<a id="ga9dc086d26daac255e9c18dc5216d99c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9dc086d26daac255e9c18dc5216d99c1">&sect;&nbsp;</a></span>divide_columns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of a matrix by a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>Vector of elements to divide each column of <code>A</code> by element-wise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>B</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the input matrices do not have matching dimensions </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00030">30</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a id="gadbf223f44b8e6a13e709c0179127fa8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf223f44b8e6a13e709c0179127fa8f">&sect;&nbsp;</a></span>divide_columns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stan::math::divide_columns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Divides each column of a matrix by a scalar. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>Matrix to divide </td></tr>
    <tr><td class="paramname">divisor</td><td>scalar to divide by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>element-wise division of <code>A</code> by <code>divisor</code>. </dd></dl>

<p>Definition at line <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html#l00056">56</a> of file <a class="el" href="../../d2/d73/opencl_2prim_2divide__columns_8hpp_source.html">divide_columns.hpp</a>.</p>

</div>
</div>
<a id="ga9850bbd8d516b87d722ad54947bb9c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9850bbd8d516b87d722ad54947bb9c9f">&sect;&nbsp;</a></span>either() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::either </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in any of the input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00019">19</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="gae46253a70141bc9eef9e6fe5bf278b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae46253a70141bc9eef9e6fe5bf278b78">&sect;&nbsp;</a></span>either() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::either </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>left_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>right_view</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines which parts are nonzero in any of the input views. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left_view</td><td>first view </td></tr>
    <tr><td class="paramname">right_view</td><td>second view </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>combined view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00107">107</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga27e938e6fdd621c5903cc37401c54909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e938e6fdd621c5903cc37401c54909">&sect;&nbsp;</a></span>from_eigen_uplo_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::from_eigen_uplo_type </td>
          <td>(</td>
          <td class="paramtype">Eigen::UpLoType&#160;</td>
          <td class="paramname"><em>eigen_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a view from <code>Eigen::UpLoType</code>. </p>
<p><code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">Eigen::Lower</a></code>, <code>Eigen::StrictlyLower</code> and <code>Eigen::UnitLower</code> become <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">PartialViewCL::Lower</a></code>. Similar for <code>Upper</code>. Any other view becomes <code><a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">PartialViewCL::Entire</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">eigen_type</td><td><code>UpLoType</code> to create a view from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00086">86</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga92137405557af2d110b4f82887488e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92137405557af2d110b4f82887488e71">&sect;&nbsp;</a></span>from_matrix_cl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R = Eigen::Dynamic, int C = Eigen::Dynamic, typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::Matrix&lt;T, R, C&gt; stan::math::from_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix with a copy of the data in the source matrix </dd></dl>
<p>Reads the contents of the OpenCL buffer starting at the offset 0 to the <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix CL_TRUE denotes that the call is blocking We do not want to pass data back to the CPU until all of the jobs called on the source matrix are finished.</p>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00078">78</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga513debd5fdb603fc031e9fd8e7999521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga513debd5fdb603fc031e9fd8e7999521">&sect;&nbsp;</a></span>from_matrix_cl_error_code()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T stan::math::from_matrix_cl_error_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy A 1 by 1 source matrix from the Device to the host. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>A 1x1 matrix on the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>dst Arithmetic to receive the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> value. </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00212">212</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga81b531a8000a627662cc92ea71bc78e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81b531a8000a627662cc92ea71bc78e1">&sect;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename K = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cl::Event&gt; <a class="el" href="../../dd/d1d/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1select__event__helper.html">stan::math::opencl_kernels::internal::select_event_helper</a>&lt; T, K &gt;::get </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the events from a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>. </p>
<p>For non <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> types this will do nothing. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A type to extract the event from. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00154">154</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gad5621902e224a5a5392177af1277d440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5621902e224a5a5392177af1277d440">&sect;&nbsp;</a></span>get_kernel_args() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; stan::math::opencl_kernels::internal::get_kernel_args </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the kernel's arguments, used in the global and local kernel constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">For</td><td>this general template the function will return back the value passed in. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The type that will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the input t. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga8bebcf5695e7745e939955d1748c2c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bebcf5695e7745e939955d1748c2c52">&sect;&nbsp;</a></span>get_kernel_args() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename K &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const cl::Buffer&amp; stan::math::opencl_kernels::internal::get_kernel_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extracts the kernel's arguments, used in the global and local kernel constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">K</td><td>The type of the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The <code>matrix</code> with an OpenCL Buffer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OpenCL Buffer. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gab6585fe09d1feeca2af78de1527c1ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6585fe09d1feeca2af78de1527c1ab3">&sect;&nbsp;</a></span>get_option()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">stan::math::opencl_kernels::kernel_cl</a>&lt; Args &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>option_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves an option used for compiling the kernel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option_name</td><td>which option to retrieve </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>option value </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00346">346</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gad618bb355838ab832cb4cd42b563de32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad618bb355838ab832cb4cd42b563de32">&sect;&nbsp;</a></span>get_opts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, int&gt;&amp; <a class="el" href="../../d6/db1/classstan_1_1math_1_1opencl__kernels_1_1kernel__functor.html">stan::math::opencl_kernels::kernel_functor</a>&lt; Args &gt;::get_opts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The options that the kernel was compiled with. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00276">276</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gaa686087fcae5e7016b355ceb3cf45846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa686087fcae5e7016b355ceb3cf45846">&sect;&nbsp;</a></span>gp_exp_quad_cov() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2, T3&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squared exponential kernel on the GPU. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T3</td><td>Type of length_scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x. </dd></dl>

<p>Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a id="ga9ebc1c13865b66015a0f30739b18b28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ebc1c13865b66015a0f30739b18b28f">&sect;&nbsp;</a></span>gp_exp_quad_cov() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2, T3, T4&gt; &gt; stan::math::gp_exp_quad_cov </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T4&#160;</td>
          <td class="paramname"><em>length_scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Squared exponential kernel on the GPU. </p>
<p>This function is for the cross covariance matrix needed to compute the posterior predictive density.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of the first matrix </td></tr>
    <tr><td class="paramname">T2</td><td>Type of the second matrix </td></tr>
    <tr><td class="paramname">T3</td><td>Type of sigma </td></tr>
    <tr><td class="paramname">T4</td><td>Type of length scale </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>first input vector or matrix </td></tr>
    <tr><td class="paramname">y</td><td>second input vector or matrix </td></tr>
    <tr><td class="paramname">sigma</td><td>standard deviation </td></tr>
    <tr><td class="paramname">length_scale</td><td>length scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Squared distance between elements of x and y. </dd></dl>

<p>Definition at line <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html#l00060">60</a> of file <a class="el" href="../../d9/dcc/opencl_2prim_2gp__exp__quad__cov_8hpp_source.html">gp_exp_quad_cov.hpp</a>.</p>

</div>
</div>
<a id="ga5d66a071139027ac3de753839511f7f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5d66a071139027ac3de753839511f7f8">&sect;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::identity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows_cols</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the identity matrix stored on the OpenCL device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rows_cols</td><td>the number of rows and columns</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identity matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/d0e/identity_8hpp_source.html#l00024">24</a> of file <a class="el" href="../../d7/d0e/identity_8hpp_source.html">identity.hpp</a>.</p>

</div>
</div>
<a id="ga747f014e58d824281b725a7d4868dd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga747f014e58d824281b725a7d4868dd77">&sect;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inverts a view. </p>
<p>Parts that are zero in the input become nonzero in output and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to invert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>inverted view </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00071">71</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="ga50bc37f3375c76b0c793a0fcc0fe3eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50bc37f3375c76b0c793a0fcc0fe3eaa">&sect;&nbsp;</a></span>max_thread_block_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int stan::math::opencl_context::max_thread_block_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum thread block size defined by CL_DEVICE_MAX_WORK_GROUP_SIZE for the device in the context. </p>
<p>This is the maximum product of thread block dimensions for a particular device. IE a max workgroup of 256 would allow thread blocks of sizes (16,16), (128,2), (8, 32), etc. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00351">351</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga1797f2d54fbce7486c5080ce2b036824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1797f2d54fbce7486c5080ce2b036824">&sect;&nbsp;</a></span>multiply()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;<a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T1, T2&gt; &gt; stan::math::opencl::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices. </p>
<p>Computes the matrix multiplication C[M, K] = A[M, N] x B[N, K]</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>first matrix </td></tr>
    <tr><td class="paramname">B</td><td>second matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">partial_view_A</td><td>specifies whether the matrix A is a lower/upper triangular or a rectangular matrix </td></tr>
    <tr><td class="paramname">partial_view_B</td><td>specifies whether the matrix B is a lower/upper triangular or a rectangular matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the first and second matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the number of columns in A and rows in B do not match </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/d5a/opencl_2multiply_8hpp_source.html#l00037">37</a> of file <a class="el" href="../../dc/d5a/opencl_2multiply_8hpp_source.html">multiply.hpp</a>.</p>

</div>
</div>
<a id="ga72e3539ba6e81a0a69e69f09c683252a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga72e3539ba6e81a0a69e69f09c683252a">&sect;&nbsp;</a></span>multiply_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::multiply_transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the product of a square OpenCL matrix with its transpose. </p>
<p>Computes the matrix multiplication C = A x A^T</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of the input matrix and its transpose </dd></dl>

<p>Definition at line <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html#l00025">25</a> of file <a class="el" href="../../d7/d28/multiply__transpose_8hpp_source.html">multiply_transpose.hpp</a>.</p>

</div>
</div>
<a id="gaf44651e3e529d18cba46f4a693383af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf44651e3e529d18cba46f4a693383af0">&sect;&nbsp;</a></span>neg_binomial_2_log_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_alpha , typename T_beta , typename T_precision &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_alpha, T_beta, T_precision&gt; stan::math::neg_binomial_2_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_precision &amp;&#160;</td>
          <td class="paramname"><em>phi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function. </p>
<p>The idea is that neg_binomial_2_log_glm_lpmf(y, x, alpha, beta, phi) should compute a more efficient version of neg_binomial_2_log_lpmf(y, alpha + x * beta, phi) by using analytically simplified gradients. If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in prim/prob/neg_binomial_2_log_glm_lpdf.hpp that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a scalar; </td></tr>
    <tr><td class="paramname">T_precision</td><td>type of the (positive) precision(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>failures count scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">phi</td><td>(vector of) precision parameter(s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if phi is infinite or non-positive. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../d5/def/opencl_2prim_2neg__binomial__2__log__glm__lpmf_8hpp_source.html">neg_binomial_2_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="gad8424b464454c363620c990897ef2988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8424b464454c363620c990897ef2988">&sect;&nbsp;</a></span>normal_id_glm_lpdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_alpha , typename T_beta , typename T_scale &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_alpha, T_beta, T_scale&gt; stan::math::normal_id_glm_lpdf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_scale &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function. </p>
<p>If containers are supplied, returns the log sum of the probabilities. This is an overload of the GLM in <a class="el" href="../../de/d31/prim_2prob_2normal__id__glm__lpdf_8hpp.html">prim/prob/normal_id_glm_lpdf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a single value; </td></tr>
    <tr><td class="paramname">T_scale</td><td>type of the (positive) scale(s); this can be a vector (of the same length as y, for heteroskedasticity) or a scalar. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">sigma</td><td>(Sequence of) scale parameters for the normal distribution. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if the scale is not positive. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html#l00050">50</a> of file <a class="el" href="../../d1/dc0/opencl_2prim_2normal__id__glm__lpdf_8hpp_source.html">normal_id_glm_lpdf.hpp</a>.</p>

</div>
</div>
<a id="ga4645f90b937230d0a8ed0772c80d582f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4645f90b937230d0a8ed0772c80d582f">&sect;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<div class="memtemplate">
template&lt;typename... CallArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">stan::math::opencl_kernels::kernel_cl</a>&lt; Args &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">cl::NDRange&#160;</td>
          <td class="paramname"><em>global_thread_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CallArgs &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallArgs</td><td>The types of the callee arguments. </td></tr>
    <tr><td class="paramname">Args</td><td>Parameter pack of all kernel argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_thread_size</td><td>The global work size. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Opencl event. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00307">307</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga912062e483d281d341511cb52b6e8986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga912062e483d281d341511cb52b6e8986">&sect;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
<div class="memtemplate">
template&lt;typename... CallArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="../../d8/d68/structstan_1_1math_1_1opencl__kernels_1_1kernel__cl.html">stan::math::opencl_kernels::kernel_cl</a>&lt; Args &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">cl::NDRange&#160;</td>
          <td class="paramname"><em>global_thread_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl::NDRange&#160;</td>
          <td class="paramname"><em>thread_block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CallArgs &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes a kernel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CallArgs</td><td>The types of the callee arguments. </td></tr>
    <tr><td class="paramname">Args</td><td>Parameter pack of all kernel argument types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">global_thread_size</td><td>The global work size. </td></tr>
    <tr><td class="paramname">thread_block_size</td><td>The thread block size. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments to pass to the kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An Opencl event. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00329">329</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="ga6c532b6185c0b35491a2db6718456152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c532b6185c0b35491a2db6718456152">&sect;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt;&amp; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00467">467</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga423fbbcc22da659e6e8a1167a9549440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga423fbbcc22da659e6e8a1167a9549440">&sect;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt;&amp; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00481">481</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga95d7f07bfe2244b8eb5a8132f18b4729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga95d7f07bfe2244b8eb5a8132f18b4729">&sect;&nbsp;</a></span>ordered_logistic_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_beta_scalar , typename T_cuts_scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_beta_scalar, T_cuts_scalar&gt; stan::math::ordered_logistic_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_beta_scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>beta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Matrix&lt; T_cuts_scalar, Eigen::Dynamic, 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the ordinal regression Generalized Linear Model (GLM). </p>
<p>This is equivalent to and faster than ordered_logistic_lpmf(y, x * beta, cuts). This is an overload of the GLM in <a class="el" href="../../da/d4f/prim_2prob_2ordered__logistic__glm__lpmf_8hpp.html">prim/prob/ordered_logistic_glm_lpmf.hpp</a> that is implemented in OpenCL.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_beta_scalar</td><td>type of a scalar in the vector of weights </td></tr>
    <tr><td class="paramname">T_cuts_scalar</td><td>type of a scalar in the vector of cutpoints </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>a scalar or vector of classes on OpenCL device. If it is a scalar it will be broadcast - used for all instances. Values should be between 1 and number of classes, including endpoints. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix or row vector on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
    <tr><td class="paramname">cuts</td><td>cutpoints vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>If any class is not between 1 and the number of cutpoints plus 2 or if the cutpoint vector is not sorted in ascending order or any input is not finite </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html#l00044">44</a> of file <a class="el" href="../../d9/dbc/opencl_2prim_2ordered__logistic__glm__lpmf_8hpp_source.html">ordered_logistic_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga8613031c3585afb538d2ea250bdd4b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8613031c3585afb538d2ea250bdd4b55">&sect;&nbsp;</a></span>packed_copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Packs the flat triangular matrix on the OpenCL device and copies it to the std::vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the flat triangular source matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the packed std::vector </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not triangular </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00114">114</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaed1f7da1a49ff3c2a9e1147b4eef4662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed1f7da1a49ff3c2a9e1147b4eef4662">&sect;&nbsp;</a></span>packed_copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_vector_vt&lt; std::is_arithmetic, Vec &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;Vec_scalar&gt; stan::math::packed_copy </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">matrix_view</td><td>the triangularity of the source matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>the packed source std::vector </td></tr>
    <tr><td class="paramname">rows</td><td>the number of rows in the flat matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the destination flat matrix on the OpenCL device </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the size of the vector does not match the expected size for the packed triangular matrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00163">163</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga625a1a3adc98d4d40402fdab8ff2fee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga625a1a3adc98d4d40402fdab8ff2fee5">&sect;&nbsp;</a></span>platform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;cl::Platform&gt; stan::math::opencl_context::platform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector containing the OpenCL platform used to create the context. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00372">372</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga599f61cbbaa77aff34e9dd7e44946298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga599f61cbbaa77aff34e9dd7e44946298">&sect;&nbsp;</a></span>poisson_log_glm_lpmf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool propto, typename T_alpha , typename T_beta &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/de1/group__type__trait.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt;T_alpha, T_beta&gt; stan::math::poisson_log_glm_lpmf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>y_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x_cl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_alpha &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T_beta &amp;&#160;</td>
          <td class="paramname"><em>beta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function. </p>
<p>This is an overload of the GLM in <a class="el" href="../../d3/dd2/prim_2prob_2poisson__log__glm__lpmf_8hpp.html">prim/prob/poisson_log_glm_lpmf.hpp</a> that is implemented in OpenCL. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T_alpha</td><td>type of the intercept(s); this can be a vector (of the same length as y) of intercepts or a single value (for models with constant intercept); </td></tr>
    <tr><td class="paramname">T_beta</td><td>type of the weight vector; this can also be a single value; </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_cl</td><td>positive integer scalar or vector parameter on OpenCL device. If it is a scalar it will be broadcast - used for all instances. </td></tr>
    <tr><td class="paramname">x_cl</td><td>design matrix on OpenCL device. This overload does not support broadcasting of a row vector x! </td></tr>
    <tr><td class="paramname">alpha</td><td>intercept (in log odds) </td></tr>
    <tr><td class="paramname">beta</td><td>weight vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>log probability or log sum of probabilities </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::domain_error</td><td>if x, beta or alpha is infinite. </td></tr>
    <tr><td class="paramname">std::domain_error</td><td>if y is negative. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if container sizes mismatch. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../dc/dbf/opencl_2prim_2poisson__log__glm__lpmf_8hpp_source.html">poisson_log_glm_lpmf.hpp</a>.</p>

</div>
</div>
<a id="ga4205ef2a3b5546a9c8b9c23377b43a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4205ef2a3b5546a9c8b9c23377b43a16">&sect;&nbsp;</a></span>queue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl::CommandQueue&amp; stan::math::opencl_context::queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the reference to the active OpenCL command queue for the device. </p>
<p>One command queue will exist per device where kernels are placed on the command queue and by default executed in order. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00335">335</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga108943105e9393ccfcc5a823fd09fef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga108943105e9393ccfcc5a823fd09fef5">&sect;&nbsp;</a></span>read_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cl::Event&gt;&amp; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::read_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the events from the event stacks. </p>
<dl class="section return"><dt>Returns</dt><dd>The read/write event stack. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00105">105</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="gaac6bf57efead4194de30b7e77ef83ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac6bf57efead4194de30b7e77ef83ec9">&sect;&nbsp;</a></span>read_write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cl::Event&gt; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::read_write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the events from the event stacks. </p>
<dl class="section return"><dt>Returns</dt><dd>The read/write event stack. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00113">113</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga480e7b2d228e7bb71d6160c87349464a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga480e7b2d228e7bb71d6160c87349464a">&sect;&nbsp;</a></span>rep_matrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>. </p>
<p>The element must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td></tr>
    <tr><td class="paramname">n</td><td>number of rows in the results matrix </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00033">33</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="ga9619e09e2ee9450bbcc70f11a8076668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9619e09e2ee9450bbcc70f11a8076668">&sect;&nbsp;</a></span>rep_matrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::rep_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> by replicating the input vector or row_vector. </p>
<p>The elements of the vector or row_vector must be of arithmetic type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> (vector or row_vector) </td></tr>
    <tr><td class="paramname">m</td><td>number of rows (if x is a row_vector) or columns (if x is a vector) in the results matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>result matrix with replicated rows or columns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html#l00067">67</a> of file <a class="el" href="../../da/df2/opencl_2prim_2rep__matrix_8hpp_source.html">rep_matrix.hpp</a>.</p>

</div>
</div>
<a id="ga5f940240b9c947f73f5871c9fbaed378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f940240b9c947f73f5871c9fbaed378">&sect;&nbsp;</a></span>rep_row_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::rep_row_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> representing a row_vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td></tr>
    <tr><td class="paramname">m</td><td>number of columns in the results vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../dd/dc5/opencl_2prim_2rep__row__vector_8hpp_source.html">rep_row_vector.hpp</a>.</p>

</div>
</div>
<a id="ga1c5cacb7a3b780ce375aec0449229e03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c5cacb7a3b780ce375aec0449229e03">&sect;&nbsp;</a></span>rep_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::rep_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> representing a vector by replicating the value of the only element in the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>type of elements in the input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>the input 1x1 <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> </td></tr>
    <tr><td class="paramname">m</td><td>number of rows in the results row_vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with replicated value from the input matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;domain_error&lt;/code&gt;</td><td>if the requested dimensions are negative </td></tr>
    <tr><td class="paramname">&lt;code&gt;invalid_argument&lt;/code&gt;</td><td>if input element is not a <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> of size 1 </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../df/dcd/opencl_2prim_2rep__vector_8hpp_source.html">rep_vector.hpp</a>.</p>

</div>
</div>
<a id="ga3f28e6eca7f3ab2b173f9b605db66805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3f28e6eca7f3ab2b173f9b605db66805">&sect;&nbsp;</a></span>select_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename K  = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cl::Event&gt; stan::math::opencl_kernels::internal::select_events </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Select events from kernel arguments. </p>
<p>Does nothing for non <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> types. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The argument type for a non <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>, else the in/out/in_out buffer types. </td></tr>
    <tr><td class="paramname">K</td><td>The type of the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>If an <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>, gets the event vector, else this argument does nothing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of OpenCL events. </dd></dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00193">193</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gaa774e31398b590ca1564e7f0ec8ffe63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa774e31398b590ca1564e7f0ec8ffe63">&sect;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename K = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d4/d5a/structstan_1_1math_1_1opencl__kernels_1_1internal_1_1assign__event__helper.html">stan::math::opencl_kernels::internal::assign_event_helper</a>&lt; T, K &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const cl::Event &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; K &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns the event to the <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>the event to be assigned. </td></tr>
    <tr><td class="paramname">m</td><td>The <code><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></code> to be assigned to. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html#l00064">64</a> of file <a class="el" href="../../dd/d60/kernel__cl_8hpp_source.html">kernel_cl.hpp</a>.</p>

</div>
</div>
<a id="gaba77ee14ccb6e86a8dd7f83aa0fe94d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba77ee14ccb6e86a8dd7f83aa0fe94d2">&sect;&nbsp;</a></span>sub_block()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::sub_block </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>A_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>A_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>this_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>this_j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the contents of A into <code>this</code> starting at the top left of <code>this</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>input matrix </td></tr>
    <tr><td class="paramname">A_i</td><td>the offset row in A </td></tr>
    <tr><td class="paramname">A_j</td><td>the offset column in A </td></tr>
    <tr><td class="paramname">this_i</td><td>the offset row for the matrix to be subset into </td></tr>
    <tr><td class="paramname">this_j</td><td>the offset col for the matrix to be subset into </td></tr>
    <tr><td class="paramname">nrows</td><td>the number of rows in the submatrix </td></tr>
    <tr><td class="paramname">ncols</td><td>the number of columns in the submatrix </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d5/dbd/sub__block_8hpp_source.html#l00031">31</a> of file <a class="el" href="../../d5/dbd/sub__block_8hpp_source.html">sub_block.hpp</a>.</p>

</div>
</div>
<a id="gad96a59b0196ef4571bbabb1576d06e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad96a59b0196ef4571bbabb1576d06e59">&sect;&nbsp;</a></span>to_matrix_cl() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Mat , typename Mat_scalar  = scalar_type_t&lt;Mat&gt;, require_eigen_vt&lt; std::is_arithmetic, Mat &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;Mat_scalar&gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">Mat &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix to the destination matrix that is stored on the OpenCL device. </p>
<p>If a lvalue matrix is passed to this function the caller must make sure that the matrix does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source <a class="el" href="../../d0/da5/namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables. ">Eigen</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00045">45</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gaf34ee44f7f6c3329cb71f358f01d34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf34ee44f7f6c3329cb71f358f01d34e5">&sect;&nbsp;</a></span>to_matrix_cl() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, require_std_vector_vt&lt; std::is_arithmetic, Vec &gt; ...&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;Vec_scalar&gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">Vec &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the source <code>std::vector</code> to the destination matrix that is stored on the OpenCL device. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source std::vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> with a copy of the data in the source matrix </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00064">64</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="ga9d7980457fe59c29a88d7484852051fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d7980457fe59c29a88d7484852051fa">&sect;&nbsp;</a></span>to_matrix_cl() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = require_arithmetic_t&lt;std::decay_t&lt;T&gt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;std::decay_t&lt;T&gt; &gt; stan::math::to_matrix_cl </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy an arithmetic type to the device. </p>
<p>If a lvalue is passed to this constructor the caller must make sure that it does not go out of scope before copying is complete.</p>
<p>That means <code>.wait()</code> must be called on the event associated on copying or any other event that requires completion of this event. This can be done by calling <code>.wait_for_write_events()</code> or <code>.wait_for_read_write_events()</code> on returned matrix or any matrix that is calculated from that one.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>An arithmetic type to pass the value from the OpenCL matrix to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Arithmetic to receive the <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a> value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 1x1 matrix on the device. </dd></dl>

<p>Definition at line <a class="el" href="../../d7/deb/copy_8hpp_source.html#l00246">246</a> of file <a class="el" href="../../d7/deb/copy_8hpp_source.html">copy.hpp</a>.</p>

</div>
</div>
<a id="gafccee2b081b9edd7c6e6d211157e5490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafccee2b081b9edd7c6e6d211157e5490">&sect;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> stan::math::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d84/namespacestan_1_1math.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td>
          <td class="paramname"><em>view</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transposes a view - swaps lower and upper parts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>view to transpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transposition of input </dd></dl>

<p>Definition at line <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../dc/db9/matrix__cl__view_8hpp_source.html">matrix_cl_view.hpp</a>.</p>

</div>
</div>
<a id="gaaf49d35bbb3fe115e5183971fba5ddad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaf49d35bbb3fe115e5183971fba5ddad">&sect;&nbsp;</a></span>tri_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view = matrix_cl_view::Entire, typename T , typename  = require_floating_point_t&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt;T&gt; stan::math::tri_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the inverse of a triangular matrix. </p>
<p>For a full guide to how this works and fits into Cholesky decompositions, see the reference report <a href="https://github.com/SteveBronder/stancon2018/blob/master/report.pdf">here</a> and kernel doc <a href="https://github.com/stan-dev/math/wiki/GPU-Kernels">here</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>matrix on the OpenCL device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the inverse of A</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html#l00040">40</a> of file <a class="el" href="../../d4/dfb/tri__inverse_8hpp_source.html">tri_inverse.hpp</a>.</p>

</div>
</div>
<a id="gae9d851223d1e89198e00e4b0436389d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9d851223d1e89198e00e4b0436389d6">&sect;&nbsp;</a></span>triangular_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;TriangularMapCL triangular_map&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::triangular_transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the lower/upper triangle of a matrix to its upper/lower triangle. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">triangular_map</td><td>Specifies if the copy is lower-to-upper or upper-to-lower triangular. The value must be of type TriangularMap</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix is not square. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../d2/dbd/triangular__transpose_8hpp_source.html#l00029">29</a> of file <a class="el" href="../../d2/dbd/triangular__transpose_8hpp_source.html">triangular_transpose.hpp</a>.</p>

</div>
</div>
<a id="gae215f1e6c88ed2690ae6c608689d5c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae215f1e6c88ed2690ae6c608689d5c11">&sect;&nbsp;</a></span>tuning_opts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../db/d9c/structstan_1_1math_1_1opencl__context__base_1_1tuning__struct.html">opencl_context_base::tuning_struct</a>&amp; stan::math::opencl_context::tuning_opts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the thread block size for the Cholesky Decompositions L_11. </p>

<p>Definition at line <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html#l00358">358</a> of file <a class="el" href="../../d3/d1b/opencl__context_8hpp_source.html">opencl_context.hpp</a>.</p>

</div>
</div>
<a id="ga3e9952ba849d1603dd6eba78fc0ee16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e9952ba849d1603dd6eba78fc0ee16a">&sect;&nbsp;</a></span>wait_for_read_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::wait_for_read_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the read events and clears the read event stack. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00155">155</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="gae5e337c8923957cfbb050b50e49c515b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5e337c8923957cfbb050b50e49c515b">&sect;&nbsp;</a></span>wait_for_read_write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::wait_for_read_write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for read and write events to finish and clears the read, write, and read/write event stacks. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00166">166</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga2b954f61c3febc8c94948323c6af1a66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b954f61c3febc8c94948323c6af1a66">&sect;&nbsp;</a></span>wait_for_write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::wait_for_write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for the write events and clears the read event stack. </p>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00145">145</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga253726d88d973fc5857da4789f966ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga253726d88d973fc5857da4789f966ead">&sect;&nbsp;</a></span>write_events()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;cl::Event&gt;&amp; <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::write_events </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the events from the event stacks. </p>
<dl class="section return"><dt>Returns</dt><dd>The write event stack. </dd></dl>

<p>Definition at line <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html#l00097">97</a> of file <a class="el" href="../../d6/dbf/matrix__cl_8hpp_source.html">matrix_cl.hpp</a>.</p>

</div>
</div>
<a id="ga1fe035fb9b34a567b1fee336285485ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fe035fb9b34a567b1fee336285485ac">&sect;&nbsp;</a></span>zeros()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::zeros </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores zeros in the matrix on the OpenCL device. </p>
<p>Supports writing zeroes to the lower and upper triangular or the whole matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">view</td><td>Specifies if zeros are assigned to the entire matrix, lower triangular or upper triangular. The value must be of type matrix_cl_view </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d67/zeros_8hpp_source.html#l00028">28</a> of file <a class="el" href="../../df/d67/zeros_8hpp_source.html">zeros.hpp</a>.</p>

</div>
</div>
<a id="gafc7229e0fe73c06f93cdd8116180c9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc7229e0fe73c06f93cdd8116180c9d6">&sect;&nbsp;</a></span>zeros_strict_tri()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;matrix_cl_view matrix_view&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d15/classstan_1_1math_1_1matrix__cl.html">stan::math::matrix_cl</a>&lt; T, <a class="el" href="../../dd/d15/group__arithmetic__types.html#ga2eb51ab4594f5791df64be0ee799488b">require_arithmetic_t</a>&lt; T &gt; &gt;::zeros_strict_tri </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores zeros in the strict's triangular part (excluding the diagonal) of a matrix on the OpenCL device. </p>
<p>Supports writing zeroes to the lower and upper triangular. Throws if used with the Entire matrix_cl_view.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">view</td><td>Specifies if zeros are assigned to the lower triangular or upper triangular. The value must be of type matrix_cl_view</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">&lt;code&gt;std::invalid_argument&lt;/code&gt;</td><td>if the matrix_view parameter is Entire. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="../../df/d67/zeros_8hpp_source.html#l00055">55</a> of file <a class="el" href="../../df/d67/zeros_8hpp_source.html">zeros.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
